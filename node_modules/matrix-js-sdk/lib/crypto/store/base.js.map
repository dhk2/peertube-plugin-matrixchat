{"version":3,"file":"base.js","names":[],"sources":["../../../src/crypto/store/base.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { IRoomKeyRequestBody, IRoomKeyRequestRecipient } from \"../index\";\nimport { RoomKeyRequestState } from \"../OutgoingRoomKeyRequestManager\";\nimport { ICrossSigningKey } from \"../../client\";\nimport { IOlmDevice } from \"../algorithms/megolm\";\nimport { TrackingStatus } from \"../DeviceList\";\nimport { IRoomEncryption } from \"../RoomList\";\nimport { IDevice } from \"../deviceinfo\";\nimport { ICrossSigningInfo } from \"../CrossSigning\";\nimport { PrefixedLogger } from \"../../logger\";\nimport { InboundGroupSessionData } from \"../OlmDevice\";\nimport { MatrixEvent } from \"../../models/event\";\nimport { DehydrationManager } from \"../dehydration\";\nimport { IEncryptedPayload } from \"../aes\";\n\n/**\n * Internal module. Definitions for storage for the crypto module\n */\n\nexport interface SecretStorePrivateKeys {\n    \"dehydration\": {\n        keyInfo: DehydrationManager[\"keyInfo\"];\n        key: IEncryptedPayload;\n        deviceDisplayName: string;\n        time: number;\n    } | null;\n    \"m.megolm_backup.v1\": IEncryptedPayload;\n}\n\n/**\n * Abstraction of things that can store data required for end-to-end encryption\n */\nexport interface CryptoStore {\n    startup(): Promise<CryptoStore>;\n    deleteAllData(): Promise<void>;\n    getOrAddOutgoingRoomKeyRequest(request: OutgoingRoomKeyRequest): Promise<OutgoingRoomKeyRequest>;\n    getOutgoingRoomKeyRequest(requestBody: IRoomKeyRequestBody): Promise<OutgoingRoomKeyRequest | null>;\n    getOutgoingRoomKeyRequestByState(wantedStates: number[]): Promise<OutgoingRoomKeyRequest | null>;\n    getAllOutgoingRoomKeyRequestsByState(wantedState: number): Promise<OutgoingRoomKeyRequest[]>;\n    getOutgoingRoomKeyRequestsByTarget(\n        userId: string,\n        deviceId: string,\n        wantedStates: number[],\n    ): Promise<OutgoingRoomKeyRequest[]>;\n    updateOutgoingRoomKeyRequest(\n        requestId: string,\n        expectedState: number,\n        updates: Partial<OutgoingRoomKeyRequest>,\n    ): Promise<OutgoingRoomKeyRequest | null>;\n    deleteOutgoingRoomKeyRequest(requestId: string, expectedState: number): Promise<OutgoingRoomKeyRequest | null>;\n\n    // Olm Account\n    getAccount(txn: unknown, func: (accountPickle: string | null) => void): void;\n    storeAccount(txn: unknown, accountPickle: string): void;\n    getCrossSigningKeys(txn: unknown, func: (keys: Record<string, ICrossSigningKey> | null) => void): void;\n    getSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        func: (key: SecretStorePrivateKeys[K] | null) => void,\n        type: K,\n    ): void;\n    storeCrossSigningKeys(txn: unknown, keys: Record<string, ICrossSigningKey>): void;\n    storeSecretStorePrivateKey<K extends keyof SecretStorePrivateKeys>(\n        txn: unknown,\n        type: K,\n        key: SecretStorePrivateKeys[K],\n    ): void;\n\n    // Olm Sessions\n    countEndToEndSessions(txn: unknown, func: (count: number) => void): void;\n    getEndToEndSession(\n        deviceKey: string,\n        sessionId: string,\n        txn: unknown,\n        func: (session: ISessionInfo | null) => void,\n    ): void;\n    getEndToEndSessions(\n        deviceKey: string,\n        txn: unknown,\n        func: (sessions: { [sessionId: string]: ISessionInfo }) => void,\n    ): void;\n    getAllEndToEndSessions(txn: unknown, func: (session: ISessionInfo | null) => void): void;\n    storeEndToEndSession(deviceKey: string, sessionId: string, sessionInfo: ISessionInfo, txn: unknown): void;\n    storeEndToEndSessionProblem(deviceKey: string, type: string, fixed: boolean): Promise<void>;\n    getEndToEndSessionProblem(deviceKey: string, timestamp: number): Promise<IProblem | null>;\n    filterOutNotifiedErrorDevices(devices: IOlmDevice[]): Promise<IOlmDevice[]>;\n\n    // Inbound Group Sessions\n    getEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        txn: unknown,\n        func: (groupSession: InboundGroupSessionData | null, groupSessionWithheld: IWithheld | null) => void,\n    ): void;\n    getAllEndToEndInboundGroupSessions(txn: unknown, func: (session: ISession | null) => void): void;\n    addEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void;\n    storeEndToEndInboundGroupSession(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: InboundGroupSessionData,\n        txn: unknown,\n    ): void;\n    storeEndToEndInboundGroupSessionWithheld(\n        senderCurve25519Key: string,\n        sessionId: string,\n        sessionData: IWithheld,\n        txn: unknown,\n    ): void;\n\n    // Device Data\n    getEndToEndDeviceData(txn: unknown, func: (deviceData: IDeviceData | null) => void): void;\n    storeEndToEndDeviceData(deviceData: IDeviceData, txn: unknown): void;\n    storeEndToEndRoom(roomId: string, roomInfo: IRoomEncryption, txn: unknown): void;\n    getEndToEndRooms(txn: unknown, func: (rooms: Record<string, IRoomEncryption>) => void): void;\n    getSessionsNeedingBackup(limit: number): Promise<ISession[]>;\n    countSessionsNeedingBackup(txn?: unknown): Promise<number>;\n    unmarkSessionsNeedingBackup(sessions: ISession[], txn?: unknown): Promise<void>;\n    markSessionsNeedingBackup(sessions: ISession[], txn?: unknown): Promise<void>;\n    addSharedHistoryInboundGroupSession(roomId: string, senderKey: string, sessionId: string, txn?: unknown): void;\n    getSharedHistoryInboundGroupSessions(\n        roomId: string,\n        txn?: unknown,\n    ): Promise<[senderKey: string, sessionId: string][]>;\n    addParkedSharedHistory(roomId: string, data: ParkedSharedHistory, txn?: unknown): void;\n    takeParkedSharedHistory(roomId: string, txn?: unknown): Promise<ParkedSharedHistory[]>;\n\n    // Session key backups\n    doTxn<T>(mode: Mode, stores: Iterable<string>, func: (txn: unknown) => T, log?: PrefixedLogger): Promise<T>;\n}\n\nexport type Mode = \"readonly\" | \"readwrite\";\n\nexport interface ISession {\n    senderKey: string;\n    sessionId: string;\n    sessionData?: InboundGroupSessionData;\n}\n\nexport interface ISessionInfo {\n    deviceKey?: string;\n    sessionId?: string;\n    session?: string;\n    lastReceivedMessageTs?: number;\n}\n\nexport interface IDeviceData {\n    devices: {\n        [userId: string]: {\n            [deviceId: string]: IDevice;\n        };\n    };\n    trackingStatus: {\n        [userId: string]: TrackingStatus;\n    };\n    crossSigningInfo?: Record<string, ICrossSigningInfo>;\n    syncToken?: string;\n}\n\nexport interface IProblem {\n    type: string;\n    fixed: boolean;\n    time: number;\n}\n\nexport interface IWithheld {\n    // eslint-disable-next-line camelcase\n    room_id: string;\n    code: string;\n    reason: string;\n}\n\n/**\n * Represents an outgoing room key request\n */\nexport interface OutgoingRoomKeyRequest {\n    /**\n     * Unique id for this request. Used for both an id within the request for later pairing with a cancellation,\n     * and for the transaction id when sending the to_device messages to our local server.\n     */\n    requestId: string;\n    requestTxnId?: string;\n    /**\n     * Transaction id for the cancellation, if any\n     */\n    cancellationTxnId?: string;\n    /**\n     * List of recipients for the request\n     */\n    recipients: IRoomKeyRequestRecipient[];\n    /**\n     * Parameters for the request\n     */\n    requestBody: IRoomKeyRequestBody;\n    /**\n     * current state of this request (states are defined in {@link OutgoingRoomKeyRequestManager})\n     */\n    state: RoomKeyRequestState;\n}\n\nexport interface ParkedSharedHistory {\n    senderId: string;\n    senderKey: string;\n    sessionId: string;\n    sessionKey: string;\n    keysClaimed: ReturnType<MatrixEvent[\"getKeysClaimed\"]>; // XXX: Less type dependence on MatrixEvent\n    forwardingCurve25519KeyChain: string[];\n}\n"],"mappings":""}