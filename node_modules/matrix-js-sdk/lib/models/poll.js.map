{"version":3,"file":"poll.js","names":["_polls","require","_relations","_typedEventEmitter","PollEvent","exports","filterResponseRelations","relationEvents","pollEndTimestamp","responseEvents","filter","event","isDecryptionFailure","M_POLL_RESPONSE","matches","getType","getTs","Poll","TypedEventEmitter","constructor","rootEvent","matrixClient","room","_defineProperty2","default","Set","events","undecryptableEventIds","map","getId","previousCount","undecryptableRelationsCount","undecryptableRelationEventIds","emit","UndecryptableRelations","getRoomId","Error","roomId","pollEvent","unstableExtensibleEvent","pollId","endEventId","_this$endEvent","endEvent","isEnded","isFetchingResponses","_isFetchingResponses","size","getResponses","responses","fetchResponses","onNewRelation","_this$endEvent2","M_POLL_END","validateEndEvent","refilterResponsesOnEnd","End","Number","MAX_SAFE_INTEGER","countUndecryptableEvents","length","forEach","addEvent","Responses","_this$endEvent3","_allRelations$nextBat","allRelations","relations","undefined","from","relationsNextBatch","Promise","all","decryptEventIfNeeded","Relations","name","altName","pollEndEvent","find","pollCloseTimestamp","nextBatch","_this$endEvent4","getRelations","_this$responses","removeEvent","roomCurrentState","currentState","endEventSender","getSender","maySendRedactionForEvent"],"sources":["../../src/models/poll.ts"],"sourcesContent":["/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { M_POLL_END, M_POLL_RESPONSE } from \"../@types/polls\";\nimport { MatrixClient } from \"../client\";\nimport { PollStartEvent } from \"../extensible_events_v1/PollStartEvent\";\nimport { MatrixEvent } from \"./event\";\nimport { Relations } from \"./relations\";\nimport { Room } from \"./room\";\nimport { TypedEventEmitter } from \"./typed-event-emitter\";\n\nexport enum PollEvent {\n    New = \"Poll.new\",\n    End = \"Poll.end\",\n    Update = \"Poll.update\",\n    Responses = \"Poll.Responses\",\n    Destroy = \"Poll.Destroy\",\n    UndecryptableRelations = \"Poll.UndecryptableRelations\",\n}\n\nexport type PollEventHandlerMap = {\n    [PollEvent.Update]: (event: MatrixEvent, poll: Poll) => void;\n    [PollEvent.Destroy]: (pollIdentifier: string) => void;\n    [PollEvent.End]: () => void;\n    [PollEvent.Responses]: (responses: Relations) => void;\n    [PollEvent.UndecryptableRelations]: (count: number) => void;\n};\n\nconst filterResponseRelations = (\n    relationEvents: MatrixEvent[],\n    pollEndTimestamp: number,\n): {\n    responseEvents: MatrixEvent[];\n} => {\n    const responseEvents = relationEvents.filter((event) => {\n        if (event.isDecryptionFailure()) {\n            return;\n        }\n        return (\n            M_POLL_RESPONSE.matches(event.getType()) &&\n            // From MSC3381:\n            // \"Votes sent on or before the end event's timestamp are valid votes\"\n            event.getTs() <= pollEndTimestamp\n        );\n    });\n\n    return { responseEvents };\n};\n\nexport class Poll extends TypedEventEmitter<Exclude<PollEvent, PollEvent.New>, PollEventHandlerMap> {\n    public readonly roomId: string;\n    public readonly pollEvent: PollStartEvent;\n    private _isFetchingResponses = false;\n    private relationsNextBatch: string | undefined;\n    private responses: null | Relations = null;\n    private endEvent: MatrixEvent | undefined;\n    /**\n     * Keep track of undecryptable relations\n     * As incomplete result sets affect poll results\n     */\n    private undecryptableRelationEventIds = new Set<string>();\n\n    public constructor(public readonly rootEvent: MatrixEvent, private matrixClient: MatrixClient, private room: Room) {\n        super();\n        if (!this.rootEvent.getRoomId() || !this.rootEvent.getId()) {\n            throw new Error(\"Invalid poll start event.\");\n        }\n        this.roomId = this.rootEvent.getRoomId()!;\n        this.pollEvent = this.rootEvent.unstableExtensibleEvent as unknown as PollStartEvent;\n    }\n\n    public get pollId(): string {\n        return this.rootEvent.getId()!;\n    }\n\n    public get endEventId(): string | undefined {\n        return this.endEvent?.getId();\n    }\n\n    public get isEnded(): boolean {\n        return !!this.endEvent;\n    }\n\n    public get isFetchingResponses(): boolean {\n        return this._isFetchingResponses;\n    }\n\n    public get undecryptableRelationsCount(): number {\n        return this.undecryptableRelationEventIds.size;\n    }\n\n    public async getResponses(): Promise<Relations> {\n        // if we have already fetched some responses\n        // just return them\n        if (this.responses) {\n            return this.responses;\n        }\n\n        // if there is no fetching in progress\n        // start fetching\n        if (!this.isFetchingResponses) {\n            await this.fetchResponses();\n        }\n        // return whatever responses we got from the first page\n        return this.responses!;\n    }\n\n    /**\n     *\n     * @param event - event with a relation to the rootEvent\n     * @returns void\n     */\n    public onNewRelation(event: MatrixEvent): void {\n        if (M_POLL_END.matches(event.getType()) && this.validateEndEvent(event)) {\n            this.endEvent = event;\n            this.refilterResponsesOnEnd();\n            this.emit(PollEvent.End);\n        }\n\n        // wait for poll responses to be initialised\n        if (!this.responses) {\n            return;\n        }\n\n        const pollEndTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n        const { responseEvents } = filterResponseRelations([event], pollEndTimestamp);\n\n        this.countUndecryptableEvents([event]);\n\n        if (responseEvents.length) {\n            responseEvents.forEach((event) => {\n                this.responses!.addEvent(event);\n            });\n\n            this.emit(PollEvent.Responses, this.responses);\n        }\n    }\n\n    private async fetchResponses(): Promise<void> {\n        this._isFetchingResponses = true;\n\n        // we want:\n        // - stable and unstable M_POLL_RESPONSE\n        // - stable and unstable M_POLL_END\n        // so make one api call and filter by event type client side\n        const allRelations = await this.matrixClient.relations(\n            this.roomId,\n            this.rootEvent.getId()!,\n            \"m.reference\",\n            undefined,\n            {\n                from: this.relationsNextBatch || undefined,\n            },\n        );\n\n        await Promise.all(allRelations.events.map((event) => this.matrixClient.decryptEventIfNeeded(event)));\n\n        const responses =\n            this.responses ||\n            new Relations(\"m.reference\", M_POLL_RESPONSE.name, this.matrixClient, [M_POLL_RESPONSE.altName!]);\n\n        const pollEndEvent = allRelations.events.find((event) => M_POLL_END.matches(event.getType()));\n\n        if (this.validateEndEvent(pollEndEvent)) {\n            this.endEvent = pollEndEvent;\n            this.refilterResponsesOnEnd();\n            this.emit(PollEvent.End);\n        }\n\n        const pollCloseTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n\n        const { responseEvents } = filterResponseRelations(allRelations.events, pollCloseTimestamp);\n\n        responseEvents.forEach((event) => {\n            responses.addEvent(event);\n        });\n\n        this.relationsNextBatch = allRelations.nextBatch ?? undefined;\n        this.responses = responses;\n        this.countUndecryptableEvents(allRelations.events);\n\n        // while there are more pages of relations\n        // fetch them\n        if (this.relationsNextBatch) {\n            // don't await\n            // we want to return the first page as soon as possible\n            this.fetchResponses();\n        } else {\n            // no more pages\n            this._isFetchingResponses = false;\n        }\n\n        // emit after updating _isFetchingResponses state\n        this.emit(PollEvent.Responses, this.responses);\n    }\n\n    /**\n     * Only responses made before the poll ended are valid\n     * Refilter after an end event is recieved\n     * To ensure responses are valid\n     */\n    private refilterResponsesOnEnd(): void {\n        if (!this.responses) {\n            return;\n        }\n\n        const pollEndTimestamp = this.endEvent?.getTs() || Number.MAX_SAFE_INTEGER;\n        this.responses.getRelations().forEach((event) => {\n            if (event.getTs() > pollEndTimestamp) {\n                this.responses?.removeEvent(event);\n            }\n        });\n\n        this.emit(PollEvent.Responses, this.responses);\n    }\n\n    private countUndecryptableEvents = (events: MatrixEvent[]): void => {\n        const undecryptableEventIds = events\n            .filter((event) => event.isDecryptionFailure())\n            .map((event) => event.getId()!);\n\n        const previousCount = this.undecryptableRelationsCount;\n        this.undecryptableRelationEventIds = new Set([...this.undecryptableRelationEventIds, ...undecryptableEventIds]);\n\n        if (this.undecryptableRelationsCount !== previousCount) {\n            this.emit(PollEvent.UndecryptableRelations, this.undecryptableRelationsCount);\n        }\n    };\n\n    private validateEndEvent(endEvent?: MatrixEvent): boolean {\n        if (!endEvent) {\n            return false;\n        }\n        /**\n         * Repeated end events are ignored -\n         * only the first (valid) closure event by origin_server_ts is counted.\n         */\n        if (this.endEvent && this.endEvent.getTs() < endEvent.getTs()) {\n            return false;\n        }\n\n        /**\n         * MSC3381\n         * If a m.poll.end event is received from someone other than the poll creator or user with permission to redact\n         * others' messages in the room, the event must be ignored by clients due to being invalid.\n         */\n        const roomCurrentState = this.room.currentState;\n        const endEventSender = endEvent.getSender();\n        return (\n            !!endEventSender &&\n            (endEventSender === this.rootEvent.getSender() ||\n                roomCurrentState.maySendRedactionForEvent(this.rootEvent, endEventSender))\n        );\n    }\n}\n"],"mappings":"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"}