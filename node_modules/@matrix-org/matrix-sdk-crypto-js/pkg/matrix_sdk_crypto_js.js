let imports = {};
imports['__wbindgen_placeholder__'] = module.exports;
let wasm;

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachedUint8Memory0 = null;

function getUint8Memory0() {
    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

const heap = new Array(128).fill(undefined);

heap.push(undefined, null, true, false);

let heap_next = heap.length;

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function getObject(idx) { return heap[idx]; }

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0() {
    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachedInt32Memory0;
}

function dropObject(idx) {
    if (idx < 132) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachedFloat64Memory0 = null;

function getFloat64Memory0() {
    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachedFloat64Memory0;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

const CLOSURE_DTORS = new FinalizationRegistry(state => {
    wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b)
});

function makeMutClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        const a = state.a;
        state.a = 0;
        try {
            return f(a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
                CLOSURE_DTORS.unregister(state)
            } else {
                state.a = a;
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_38(arg0, arg1, arg2) {
    try {
        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
        wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hdb9d3d24e784d1a7(retptr, arg0, arg1, addHeapObject(arg2));
        var r0 = getInt32Memory0()[retptr / 4 + 0];
        var r1 = getInt32Memory0()[retptr / 4 + 1];
        if (r1) {
            throw takeObject(r0);
        }
    } finally {
        wasm.__wbindgen_add_to_stack_pointer(16);
    }
}

function __wbg_adapter_41(arg0, arg1) {
    wasm._dyn_core__ops__function__FnMut_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h2ef6151a77bc79ca(arg0, arg1);
}

function makeClosure(arg0, arg1, dtor, f) {
    const state = { a: arg0, b: arg1, cnt: 1, dtor };
    const real = (...args) => {
        // First up with a closure we increment the internal reference
        // count. This ensures that the Rust closure environment won't
        // be deallocated while we're invoking it.
        state.cnt++;
        try {
            return f(state.a, state.b, ...args);
        } finally {
            if (--state.cnt === 0) {
                wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
                state.a = 0;
                CLOSURE_DTORS.unregister(state)
            }
        }
    };
    real.original = state;
    CLOSURE_DTORS.register(real, state, state);
    return real;
}
function __wbg_adapter_44(arg0, arg1) {
    wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h44c86e858096e0bc(arg0, arg1);
}

function __wbg_adapter_47(arg0, arg1, arg2) {
    wasm._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h3c5980aec58ec091(arg0, arg1, addHeapObject(arg2));
}

function __wbg_adapter_50(arg0, arg1, arg2) {
    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h134ef41abc81f857(arg0, arg1, addHeapObject(arg2));
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

let stack_pointer = 128;

function addBorrowedObject(obj) {
    if (stack_pointer == 1) throw new Error('out of js stack');
    heap[--stack_pointer] = obj;
    return stack_pointer;
}

function handleError(f, args) {
    try {
        return f.apply(this, args);
    } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
    }
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}
function __wbg_adapter_186(arg0, arg1, arg2, arg3) {
    wasm.wasm_bindgen__convert__closures__invoke2_mut__h69874f5b0554fc4e(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}

/**
* Get the versions of the Rust libraries we are using.
* @returns {Versions}
*/
module.exports.getVersions = function() {
    const ret = wasm.getVersions();
    return Versions.__wrap(ret);
};

/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
module.exports.start = function() {
    wasm.start();
};

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}
/**
* Who can see a room's history.
*/
module.exports.HistoryVisibility = Object.freeze({
/**
* Previous events are accessible to newly joined members from
* the point they were invited onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *invite* or *join*.
*/
Invited:0,"0":"Invited",
/**
* Previous events are accessible to newly joined members from
* the point they joined the room onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *join*.
*/
Joined:1,"1":"Joined",
/**
* Previous events are always accessible to newly joined members.
*
* All events in the room are accessible, even those sent when
* the member was not a part of the room.
*/
Shared:2,"2":"Shared",
/**
* All events while this is the `HistoryVisibility` value may be
* shared by any participating homeserver with anyone, regardless
* of whether they have ever joined the room.
*/
WorldReadable:3,"3":"WorldReadable", });
/**
* The basic key algorithm names in the specification.
*/
module.exports.DeviceKeyAlgorithmName = Object.freeze({
/**
* The Ed25519 signature algorithm.
*/
Ed25519:0,"0":"Ed25519",
/**
* The Curve25519 ECDH algorithm.
*/
Curve25519:1,"1":"Curve25519",
/**
* The Curve25519 ECDH algorithm, but the key also contains
* signatures.
*/
SignedCurve25519:2,"2":"SignedCurve25519",
/**
* An unknown device key algorithm.
*/
Unknown:3,"3":"Unknown", });
/**
* Represent the type of a request.
*/
module.exports.RequestType = Object.freeze({
/**
* Represents a `KeysUploadRequest`.
*/
KeysUpload:0,"0":"KeysUpload",
/**
* Represents a `KeysQueryRequest`.
*/
KeysQuery:1,"1":"KeysQuery",
/**
* Represents a `KeysClaimRequest`.
*/
KeysClaim:2,"2":"KeysClaim",
/**
* Represents a `ToDeviceRequest`.
*/
ToDevice:3,"3":"ToDevice",
/**
* Represents a `SignatureUploadRequest`.
*/
SignatureUpload:4,"4":"SignatureUpload",
/**
* Represents a `RoomMessageRequest`.
*/
RoomMessage:5,"5":"RoomMessage",
/**
* Represents a `KeysBackupRequest`.
*/
KeysBackup:6,"6":"KeysBackup", });
/**
* An encryption algorithm to be used to encrypt messages sent to a
* room.
*/
module.exports.EncryptionAlgorithm = Object.freeze({
/**
* Olm version 1 using Curve25519, AES-256, and SHA-256.
*/
OlmV1Curve25519AesSha2:0,"0":"OlmV1Curve25519AesSha2",
/**
* Megolm version 1 using AES-256 and SHA-256.
*/
MegolmV1AesSha2:1,"1":"MegolmV1AesSha2", });
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
module.exports.ShieldColor = Object.freeze({
/**
* Important warning
*/
Red:0,"0":"Red",
/**
* Low warning
*/
Grey:1,"1":"Grey",
/**
* No warning
*/
None:2,"2":"None", });
/**
* The local trust state of a device.
*/
module.exports.LocalTrust = Object.freeze({
/**
* The device has been verified and is trusted.
*/
Verified:0,"0":"Verified",
/**
* The device been blacklisted from communicating.
*/
BlackListed:1,"1":"BlackListed",
/**
* The trust state of the device is being ignored.
*/
Ignored:2,"2":"Ignored",
/**
* The trust state is unset.
*/
Unset:3,"3":"Unset", });
/**
* Logger level.
*/
module.exports.LoggerLevel = Object.freeze({
/**
* `TRACE` level.
*
* Designate very low priority, often extremely verbose,
* information.
*/
Trace:0,"0":"Trace",
/**
* `DEBUG` level.
*
* Designate lower priority information.
*/
Debug:1,"1":"Debug",
/**
* `INFO` level.
*
* Designate useful information.
*/
Info:2,"2":"Info",
/**
* `WARN` level.
*
* Designate hazardous situations.
*/
Warn:3,"3":"Warn",
/**
* `ERROR` level.
*
* Designate very serious errors.
*/
Error:4,"4":"Error", });
/**
* List of available verification methods.
*/
module.exports.VerificationMethod = Object.freeze({
/**
* The `m.sas.v1` verification method.
*
* SAS means Short Authentication String.
*/
SasV1:0,"0":"SasV1",
/**
* The `m.qr_code.scan.v1` verification method.
*/
QrCodeScanV1:1,"1":"QrCodeScanV1",
/**
* The `m.qr_code.show.v1` verification method.
*/
QrCodeShowV1:2,"2":"QrCodeShowV1",
/**
* The `m.reciprocate.v1` verification method.
*/
ReciprocateV1:3,"3":"ReciprocateV1", });
/**
* An error code for why the process/request was cancelled by the
* user.
*/
module.exports.CancelCode = Object.freeze({
/**
* Unknown cancel code.
*/
Other:0,"0":"Other",
/**
* The user cancelled the verification.
*/
User:1,"1":"User",
/**
* The verification process timed out.
*
* Verification processes can define their own timeout
* parameters.
*/
Timeout:2,"2":"Timeout",
/**
* The device does not know about the given transaction ID.
*/
UnknownTransaction:3,"3":"UnknownTransaction",
/**
* The device does not know how to handle the requested method.
*
* Should be sent for `m.key.verification.start` messages and
* messages defined by individual verification processes.
*/
UnknownMethod:4,"4":"UnknownMethod",
/**
* The device received an unexpected message.
*
* Typically raised when one of the parties is handling the
* verification out of order.
*/
UnexpectedMessage:5,"5":"UnexpectedMessage",
/**
* The key was not verified.
*/
KeyMismatch:6,"6":"KeyMismatch",
/**
* The expected user did not match the user verified.
*/
UserMismatch:7,"7":"UserMismatch",
/**
* The message received was invalid.
*/
InvalidMessage:8,"8":"InvalidMessage",
/**
* An `m.key.verification.request` was accepted by a different
* device.
*
* The device receiving this error can ignore the verification
* request.
*/
Accepted:9,"9":"Accepted",
/**
* The device receiving this error can ignore the verification
* request.
*/
MismatchedCommitment:10,"10":"MismatchedCommitment",
/**
* The SAS did not match.
*/
MismatchedSas:11,"11":"MismatchedSas", });
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
module.exports.DeviceKeyName = Object.freeze({
/**
* The curve25519 device key.
*/
Curve25519:0,"0":"Curve25519",
/**
* The ed25519 device key.
*/
Ed25519:1,"1":"Ed25519",
/**
* An unknown device key.
*/
Unknown:2,"2":"Unknown", });

const AttachmentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_attachment_free(ptr));
/**
* A type to encrypt and to decrypt anything that can fit in an
* `Uint8Array`, usually big buffer.
*/
class Attachment {

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        AttachmentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_attachment_free(ptr);
    }
    /**
    * Encrypt the content of the `Uint8Array`.
    *
    * It produces an `EncryptedAttachment`, which can be used to
    * retrieve the media encryption information, or the encrypted
    * data.
    * @param {Uint8Array} array
    * @returns {EncryptedAttachment}
    */
    static encrypt(array) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(array, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.attachment_encrypt(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedAttachment.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Decrypt an `EncryptedAttachment`.
    *
    * The encrypted attachment can be created manually, or from the
    * `encrypt` method.
    *
    * **Warning**: The encrypted attachment can be used only
    * **once**! The encrypted data will still be present, but the
    * media encryption info (which contain secrets) will be
    * destroyed. It is still possible to get a JSON-encoded backup
    * by calling `EncryptedAttachment.mediaEncryptionInfo`.
    * @param {EncryptedAttachment} attachment
    * @returns {Uint8Array}
    */
    static decrypt(attachment) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(attachment, EncryptedAttachment);
            wasm.attachment_decrypt(retptr, attachment.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            if (r3) {
                throw takeObject(r2);
            }
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Attachment = Attachment;

const CancelInfoFinalization = new FinalizationRegistry(ptr => wasm.__wbg_cancelinfo_free(ptr));
/**
* Information about the cancellation of a verification request or
* verification flow.
*/
class CancelInfo {

    static __wrap(ptr) {
        const obj = Object.create(CancelInfo.prototype);
        obj.ptr = ptr;
        CancelInfoFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CancelInfoFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cancelinfo_free(ptr);
    }
    /**
    * Get the human readable reason of the cancellation.
    * @returns {string}
    */
    reason() {
        const ret = wasm.cancelinfo_reason(this.ptr);
        return takeObject(ret);
    }
    /**
    * Get the `CancelCode` that cancelled this verification.
    * @returns {number}
    */
    cancelCode() {
        const ret = wasm.cancelinfo_cancelCode(this.ptr);
        return ret >>> 0;
    }
    /**
    * Was the verification cancelled by us?
    * @returns {boolean}
    */
    cancelledbyUs() {
        const ret = wasm.cancelinfo_cancelledbyUs(this.ptr);
        return ret !== 0;
    }
}
module.exports.CancelInfo = CancelInfo;

const CrossSigningKeyExportFinalization = new FinalizationRegistry(ptr => wasm.__wbg_crosssigningkeyexport_free(ptr));
/**
* A struct containing private cross signing keys that can be backed
* up or uploaded to the secret store.
*/
class CrossSigningKeyExport {

    static __wrap(ptr) {
        const obj = Object.create(CrossSigningKeyExport.prototype);
        obj.ptr = ptr;
        CrossSigningKeyExportFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CrossSigningKeyExportFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_crosssigningkeyexport_free(ptr);
    }
    /**
    * The seed of the master key encoded as unpadded base64.
    * @returns {string | undefined}
    */
    get masterKey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.crosssigningkeyexport_masterKey(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * The seed of the self signing key encoded as unpadded base64.
    * @returns {string | undefined}
    */
    get self_signing_key() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.crosssigningkeyexport_self_signing_key(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * The seed of the user signing key encoded as unpadded base64.
    * @returns {string | undefined}
    */
    get userSigningKey() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.crosssigningkeyexport_userSigningKey(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.CrossSigningKeyExport = CrossSigningKeyExport;

const CrossSigningStatusFinalization = new FinalizationRegistry(ptr => wasm.__wbg_crosssigningstatus_free(ptr));
/**
* Struct representing the state of our private cross signing keys,
* it shows which private cross signing keys we have locally stored.
*/
class CrossSigningStatus {

    static __wrap(ptr) {
        const obj = Object.create(CrossSigningStatus.prototype);
        obj.ptr = ptr;
        CrossSigningStatusFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        CrossSigningStatusFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_crosssigningstatus_free(ptr);
    }
    /**
    * Do we have the master key?
    * @returns {boolean}
    */
    get hasMaster() {
        const ret = wasm.crosssigningstatus_hasMaster(this.ptr);
        return ret !== 0;
    }
    /**
    * Do we have the self signing key? This one is necessary to sign
    * our own devices.
    * @returns {boolean}
    */
    get hasSelfSigning() {
        const ret = wasm.crosssigningstatus_hasSelfSigning(this.ptr);
        return ret !== 0;
    }
    /**
    * Do we have the user signing key? This one is necessary to sign
    * other users.
    * @returns {boolean}
    */
    get hasUserSigning() {
        const ret = wasm.crosssigningstatus_hasUserSigning(this.ptr);
        return ret !== 0;
    }
}
module.exports.CrossSigningStatus = CrossSigningStatus;

const Curve25519PublicKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_curve25519publickey_free(ptr));
/**
* A Curve25519 public key.
*/
class Curve25519PublicKey {

    static __wrap(ptr) {
        const obj = Object.create(Curve25519PublicKey.prototype);
        obj.ptr = ptr;
        Curve25519PublicKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Curve25519PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_curve25519publickey_free(ptr);
    }
    /**
    * The number of bytes a Curve25519 public key has.
    * @returns {number}
    */
    get length() {
        const ret = wasm.curve25519publickey_length(this.ptr);
        return ret >>> 0;
    }
    /**
    * Serialize an Curve25519 public key to an unpadded base64
    * representation.
    * @returns {string}
    */
    toBase64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.curve25519publickey_toBase64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.Curve25519PublicKey = Curve25519PublicKey;

const DecryptedRoomEventFinalization = new FinalizationRegistry(ptr => wasm.__wbg_decryptedroomevent_free(ptr));
/**
* A decrypted room event.
*/
class DecryptedRoomEvent {

    static __wrap(ptr) {
        const obj = Object.create(DecryptedRoomEvent.prototype);
        obj.ptr = ptr;
        DecryptedRoomEventFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DecryptedRoomEventFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_decryptedroomevent_free(ptr);
    }
    /**
    * The JSON-encoded decrypted event.
    * @returns {string}
    */
    get event() {
        const ret = wasm.__wbg_get_decryptedroomevent_event(this.ptr);
        return takeObject(ret);
    }
    /**
    * The user ID of the event sender, note this is untrusted data
    * unless the `verification_state` is as well trusted.
    * @returns {UserId | undefined}
    */
    get sender() {
        const ret = wasm.decryptedroomevent_sender(this.ptr);
        return ret === 0 ? undefined : UserId.__wrap(ret);
    }
    /**
    * The device ID of the device that sent us the event, note this
    * is untrusted data unless `verification_state` is as well
    * trusted.
    * @returns {DeviceId | undefined}
    */
    get senderDevice() {
        const ret = wasm.decryptedroomevent_senderDevice(this.ptr);
        return ret === 0 ? undefined : DeviceId.__wrap(ret);
    }
    /**
    * The Curve25519 key of the device that created the megolm
    * decryption key originally.
    * @returns {string | undefined}
    */
    get senderCurve25519Key() {
        const ret = wasm.decryptedroomevent_senderCurve25519Key(this.ptr);
        return takeObject(ret);
    }
    /**
    * The signing Ed25519 key that have created the megolm key that
    * was used to decrypt this session.
    * @returns {string | undefined}
    */
    get senderClaimedEd25519Key() {
        const ret = wasm.decryptedroomevent_senderClaimedEd25519Key(this.ptr);
        return takeObject(ret);
    }
    /**
    * Chain of Curve25519 keys through which this session was
    * forwarded, via `m.forwarded_room_key` events.
    * @returns {Array<any>}
    */
    get forwardingCurve25519KeyChain() {
        const ret = wasm.decryptedroomevent_forwardingCurve25519KeyChain(this.ptr);
        return takeObject(ret);
    }
    /**
    * The verification state of the device that sent us the event,
    * note this is the state of the device at the time of
    * decryption. It may change in the future if a device gets
    * verified or deleted.
    * @param {boolean} strict
    * @returns {ShieldState | undefined}
    */
    shieldState(strict) {
        const ret = wasm.decryptedroomevent_shieldState(this.ptr, strict);
        return ret === 0 ? undefined : ShieldState.__wrap(ret);
    }
}
module.exports.DecryptedRoomEvent = DecryptedRoomEvent;

const DeviceFinalization = new FinalizationRegistry(ptr => wasm.__wbg_device_free(ptr));
/**
* A device represents a E2EE capable client of an user.
*/
class Device {

    static __wrap(ptr) {
        const obj = Object.create(Device.prototype);
        obj.ptr = ptr;
        DeviceFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_device_free(ptr);
    }
    /**
    * Request an interactive verification with this device.
    * @param {Array<any> | undefined} methods
    * @returns {Promise<any>}
    */
    requestVerification(methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.device_requestVerification(retptr, this.ptr, isLikeNone(methods) ? 0 : addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Is this device considered to be verified.
    *
    * This method returns true if either the `is_locally_trusted`
    * method returns `true` or if the `is_cross_signing_trusted`
    * method returns `true`.
    * @returns {boolean}
    */
    isVerified() {
        const ret = wasm.device_isVerified(this.ptr);
        return ret !== 0;
    }
    /**
    * Is this device considered to be verified using cross signing.
    * @returns {boolean}
    */
    isCrossSigningTrusted() {
        const ret = wasm.device_isCrossSigningTrusted(this.ptr);
        return ret !== 0;
    }
    /**
    * Set the local trust state of the device to the given state.
    *
    * This won’t affect any cross signing trust state, this only
    * sets a flag marking to have the given trust state.
    *
    * `trust_state` represents the new trust state that should be
    * set for the device.
    * @param {number} local_state
    * @returns {Promise<any>}
    */
    setLocalTrust(local_state) {
        const ret = wasm.device_setLocalTrust(this.ptr, local_state);
        return takeObject(ret);
    }
    /**
    * The user ID of the device owner.
    * @returns {UserId}
    */
    get userId() {
        const ret = wasm.device_userId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * The unique ID of the device.
    * @returns {DeviceId}
    */
    get deviceId() {
        const ret = wasm.device_deviceId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Get the human readable name of the device.
    * @returns {string | undefined}
    */
    get displayName() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.device_displayName(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get the key of the given key algorithm belonging to this device.
    * @param {number} algorithm
    * @returns {DeviceKey | undefined}
    */
    getKey(algorithm) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.device_getKey(retptr, this.ptr, algorithm);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return r0 === 0 ? undefined : DeviceKey.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get the Curve25519 key of the given device.
    * @returns {Curve25519PublicKey | undefined}
    */
    get curve25519Key() {
        const ret = wasm.device_curve25519Key(this.ptr);
        return ret === 0 ? undefined : Curve25519PublicKey.__wrap(ret);
    }
    /**
    * Get the Ed25519 key of the given device.
    * @returns {Ed25519PublicKey | undefined}
    */
    get ed25519Key() {
        const ret = wasm.device_ed25519Key(this.ptr);
        return ret === 0 ? undefined : Ed25519PublicKey.__wrap(ret);
    }
    /**
    * Get a map containing all the device keys.
    * @returns {Map<any, any>}
    */
    get keys() {
        const ret = wasm.device_keys(this.ptr);
        return takeObject(ret);
    }
    /**
    * Get a map containing all the device signatures.
    * @returns {Signatures}
    */
    get signatures() {
        const ret = wasm.device_signatures(this.ptr);
        return Signatures.__wrap(ret);
    }
    /**
    * Get the trust state of the device.
    * @returns {number}
    */
    get localTrustState() {
        const ret = wasm.device_localTrustState(this.ptr);
        return ret >>> 0;
    }
    /**
    * Is the device locally marked as trusted?
    * @returns {boolean}
    */
    isLocallyTrusted() {
        const ret = wasm.device_isLocallyTrusted(this.ptr);
        return ret !== 0;
    }
    /**
    * Is the device locally marked as blacklisted?
    *
    * Blacklisted devices won’t receive any group sessions.
    * @returns {boolean}
    */
    isBlacklisted() {
        const ret = wasm.device_isBlacklisted(this.ptr);
        return ret !== 0;
    }
    /**
    * Is the device deleted?
    * @returns {boolean}
    */
    isDeleted() {
        const ret = wasm.device_isDeleted(this.ptr);
        return ret !== 0;
    }
}
module.exports.Device = Device;

const DeviceIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_deviceid_free(ptr));
/**
* A Matrix key ID.
*
* Device identifiers in Matrix are completely opaque character
* sequences. This type is provided simply for its semantic value.
*/
class DeviceId {

    static __wrap(ptr) {
        const obj = Object.create(DeviceId.prototype);
        obj.ptr = ptr;
        DeviceIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_deviceid_free(ptr);
    }
    /**
    * Create a new `DeviceId`.
    * @param {string} id
    */
    constructor(id) {
        const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.deviceid_new(ptr0, len0);
        return DeviceId.__wrap(ret);
    }
    /**
    * Return the device ID as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.deviceid_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.DeviceId = DeviceId;

const DeviceKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_devicekey_free(ptr));
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
class DeviceKey {

    static __wrap(ptr) {
        const obj = Object.create(DeviceKey.prototype);
        obj.ptr = ptr;
        DeviceKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_devicekey_free(ptr);
    }
    /**
    * Get the name of the device key.
    * @returns {number}
    */
    get name() {
        const ret = wasm.devicekey_name(this.ptr);
        return ret >>> 0;
    }
    /**
    * Get the value associated to the `Curve25519` device key name.
    * @returns {Curve25519PublicKey | undefined}
    */
    get curve25519() {
        const ret = wasm.devicekey_curve25519(this.ptr);
        return ret === 0 ? undefined : Curve25519PublicKey.__wrap(ret);
    }
    /**
    * Get the value associated to the `Ed25519` device key name.
    * @returns {Ed25519PublicKey | undefined}
    */
    get ed25519() {
        const ret = wasm.devicekey_ed25519(this.ptr);
        return ret === 0 ? undefined : Ed25519PublicKey.__wrap(ret);
    }
    /**
    * Get the value associated to the `Unknown` device key name.
    * @returns {string | undefined}
    */
    get unknown() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.devicekey_unknown(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Convert the `DeviceKey` into a base64 encoded string.
    * @returns {string}
    */
    toBase64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.devicekey_toBase64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.DeviceKey = DeviceKey;

const DeviceKeyAlgorithmFinalization = new FinalizationRegistry(ptr => wasm.__wbg_devicekeyalgorithm_free(ptr));
/**
* The basic key algorithms in the specification.
*/
class DeviceKeyAlgorithm {

    static __wrap(ptr) {
        const obj = Object.create(DeviceKeyAlgorithm.prototype);
        obj.ptr = ptr;
        DeviceKeyAlgorithmFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceKeyAlgorithmFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_devicekeyalgorithm_free(ptr);
    }
    /**
    * Read the device key algorithm's name. If the name is
    * `Unknown`, one may be interested by the `to_string` method to
    * read the original name.
    * @returns {number}
    */
    get name() {
        const ret = wasm.devicekeyalgorithm_name(this.ptr);
        return ret >>> 0;
    }
    /**
    * Return the device key algorithm as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.devicekeyalgorithm_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.DeviceKeyAlgorithm = DeviceKeyAlgorithm;

const DeviceKeyIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_devicekeyid_free(ptr));
/**
* A Matrix device key ID.
*
* A key algorithm and a device ID, combined with a ‘:’.
*/
class DeviceKeyId {

    static __wrap(ptr) {
        const obj = Object.create(DeviceKeyId.prototype);
        obj.ptr = ptr;
        DeviceKeyIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceKeyIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_devicekeyid_free(ptr);
    }
    /**
    * Parse/validate and create a new `DeviceKeyId`.
    * @param {string} id
    */
    constructor(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.devicekeyid_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DeviceKeyId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns key algorithm of the device key ID.
    * @returns {DeviceKeyAlgorithm}
    */
    get algorithm() {
        const ret = wasm.devicekeyid_algorithm(this.ptr);
        return DeviceKeyAlgorithm.__wrap(ret);
    }
    /**
    * Returns device ID of the device key ID.
    * @returns {DeviceId}
    */
    get deviceId() {
        const ret = wasm.devicekeyid_deviceId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Return the device key ID as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.devicekeyid_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.DeviceKeyId = DeviceKeyId;

const DeviceListsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_devicelists_free(ptr));
/**
* Information on E2E device updates.
*/
class DeviceLists {

    static __wrap(ptr) {
        const obj = Object.create(DeviceLists.prototype);
        obj.ptr = ptr;
        DeviceListsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        DeviceListsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_devicelists_free(ptr);
    }
    /**
    * Create an empty `DeviceLists`.
    *
    * `changed` and `left` must be an array of `UserId`.
    * @param {Array<any> | undefined} changed
    * @param {Array<any> | undefined} left
    */
    constructor(changed, left) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.devicelists_new(retptr, isLikeNone(changed) ? 0 : addHeapObject(changed), isLikeNone(left) ? 0 : addHeapObject(left));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return DeviceLists.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns true if there are no device list updates.
    * @returns {boolean}
    */
    isEmpty() {
        const ret = wasm.devicelists_isEmpty(this.ptr);
        return ret !== 0;
    }
    /**
    * List of users who have updated their device identity keys or
    * who now share an encrypted room with the client since the
    * previous sync
    * @returns {Array<any>}
    */
    get changed() {
        const ret = wasm.devicelists_changed(this.ptr);
        return takeObject(ret);
    }
    /**
    * List of users who no longer share encrypted rooms since the
    * previous sync response.
    * @returns {Array<any>}
    */
    get left() {
        const ret = wasm.devicelists_left(this.ptr);
        return takeObject(ret);
    }
}
module.exports.DeviceLists = DeviceLists;

const Ed25519PublicKeyFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519publickey_free(ptr));
/**
* An Ed25519 public key, used to verify digital signatures.
*/
class Ed25519PublicKey {

    static __wrap(ptr) {
        const obj = Object.create(Ed25519PublicKey.prototype);
        obj.ptr = ptr;
        Ed25519PublicKeyFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519PublicKeyFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519publickey_free(ptr);
    }
    /**
    * The number of bytes an Ed25519 public key has.
    * @returns {number}
    */
    get length() {
        const ret = wasm.ed25519publickey_length(this.ptr);
        return ret >>> 0;
    }
    /**
    * Serialize an Ed25519 public key to an unpadded base64
    * representation.
    * @returns {string}
    */
    toBase64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519publickey_toBase64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.Ed25519PublicKey = Ed25519PublicKey;

const Ed25519SignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ed25519signature_free(ptr));
/**
* An Ed25519 digital signature, can be used to verify the
* authenticity of a message.
*/
class Ed25519Signature {

    static __wrap(ptr) {
        const obj = Object.create(Ed25519Signature.prototype);
        obj.ptr = ptr;
        Ed25519SignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        Ed25519SignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ed25519signature_free(ptr);
    }
    /**
    * Try to create an Ed25519 signature from an unpadded base64
    * representation.
    * @param {string} signature
    */
    constructor(signature) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(signature, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.ed25519signature_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Ed25519Signature.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Serialize a Ed25519 signature to an unpadded base64
    * representation.
    * @returns {string}
    */
    toBase64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ed25519signature_toBase64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.Ed25519Signature = Ed25519Signature;

const EmojiFinalization = new FinalizationRegistry(ptr => wasm.__wbg_emoji_free(ptr));
/**
* An emoji that is used for interactive verification using a short
* auth string.
*
* This will contain a single emoji and description from the list of
* emojis from [the specification].
*
* [the specification]: https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji
*/
class Emoji {

    static __wrap(ptr) {
        const obj = Object.create(Emoji.prototype);
        obj.ptr = ptr;
        EmojiFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EmojiFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_emoji_free(ptr);
    }
    /**
    * The emoji symbol that represents a part of the short auth
    * string, for example: 🐶
    * @returns {string}
    */
    get symbol() {
        const ret = wasm.emoji_symbol(this.ptr);
        return takeObject(ret);
    }
    /**
    * The description of the emoji, for example ‘Dog’.
    * @returns {string}
    */
    get description() {
        const ret = wasm.emoji_description(this.ptr);
        return takeObject(ret);
    }
}
module.exports.Emoji = Emoji;

const EncryptedAttachmentFinalization = new FinalizationRegistry(ptr => wasm.__wbg_encryptedattachment_free(ptr));
/**
* An encrypted attachment, usually created from `Attachment.encrypt`.
*/
class EncryptedAttachment {

    static __wrap(ptr) {
        const obj = Object.create(EncryptedAttachment.prototype);
        obj.ptr = ptr;
        EncryptedAttachmentFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EncryptedAttachmentFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encryptedattachment_free(ptr);
    }
    /**
    * Create a new encrypted attachment manually.
    *
    * It needs encrypted data, stored in an `Uint8Array`, and a
    * [media encryption
    * information](https://docs.rs/matrix-sdk-crypto/latest/matrix_sdk_crypto/struct.MediaEncryptionInfo.html),
    * as a JSON-encoded string.
    *
    * The media encryption information aren't stored as a string:
    * they are parsed, validated and fully deserialized.
    *
    * See [the specification to learn
    * more](https://spec.matrix.org/unstable/client-server-api/#extensions-to-mroommessage-msgtypes).
    * @param {Uint8Array} encrypted_data
    * @param {string} media_encryption_info
    */
    constructor(encrypted_data, media_encryption_info) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passArray8ToWasm0(encrypted_data, wasm.__wbindgen_malloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(media_encryption_info, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.encryptedattachment_new(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EncryptedAttachment.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * The actual encrypted data.
    *
    * **Warning**: It returns a **copy** of the entire encrypted
    * data; be nice with your memory.
    * @returns {Uint8Array}
    */
    get encryptedData() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptedattachment_encryptedData(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Return the media encryption info as a JSON-encoded string. The
    * structure is fully valid.
    *
    * If the media encryption info have been consumed already, it
    * will return `null`.
    * @returns {string | undefined}
    */
    get mediaEncryptionInfo() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.encryptedattachment_mediaEncryptionInfo(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Check whether the media encryption info has been consumed by
    * `Attachment.decrypt` already.
    * @returns {boolean}
    */
    get hasMediaEncryptionInfoBeenConsumed() {
        const ret = wasm.encryptedattachment_hasMediaEncryptionInfoBeenConsumed(this.ptr);
        return ret !== 0;
    }
}
module.exports.EncryptedAttachment = EncryptedAttachment;

const EncryptionSettingsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_encryptionsettings_free(ptr));
/**
* Settings for an encrypted room.
*
* This determines the algorithm and rotation periods of a group
* session.
*/
class EncryptionSettings {

    static __wrap(ptr) {
        const obj = Object.create(EncryptionSettings.prototype);
        obj.ptr = ptr;
        EncryptionSettingsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EncryptionSettingsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_encryptionsettings_free(ptr);
    }
    /**
    * The encryption algorithm that should be used in the room.
    * @returns {number}
    */
    get algorithm() {
        const ret = wasm.__wbg_get_encryptionsettings_algorithm(this.ptr);
        return ret >>> 0;
    }
    /**
    * The encryption algorithm that should be used in the room.
    * @param {number} arg0
    */
    set algorithm(arg0) {
        wasm.__wbg_set_encryptionsettings_algorithm(this.ptr, arg0);
    }
    /**
    * How long the session should be used before changing it,
    * expressed in microseconds.
    * @returns {bigint}
    */
    get rotationPeriod() {
        const ret = wasm.__wbg_get_encryptionsettings_rotationPeriod(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * How long the session should be used before changing it,
    * expressed in microseconds.
    * @param {bigint} arg0
    */
    set rotationPeriod(arg0) {
        wasm.__wbg_set_encryptionsettings_rotationPeriod(this.ptr, arg0);
    }
    /**
    * How many messages should be sent before changing the session.
    * @returns {bigint}
    */
    get rotationPeriodMessages() {
        const ret = wasm.__wbg_get_encryptionsettings_rotationPeriodMessages(this.ptr);
        return BigInt.asUintN(64, ret);
    }
    /**
    * How many messages should be sent before changing the session.
    * @param {bigint} arg0
    */
    set rotationPeriodMessages(arg0) {
        wasm.__wbg_set_encryptionsettings_rotationPeriodMessages(this.ptr, arg0);
    }
    /**
    * The history visibility of the room when the session was
    * created.
    * @returns {number}
    */
    get historyVisibility() {
        const ret = wasm.__wbg_get_encryptionsettings_historyVisibility(this.ptr);
        return ret >>> 0;
    }
    /**
    * The history visibility of the room when the session was
    * created.
    * @param {number} arg0
    */
    set historyVisibility(arg0) {
        wasm.__wbg_set_encryptionsettings_historyVisibility(this.ptr, arg0);
    }
    /**
    * Should untrusted devices receive the room key, or should they be
    * excluded from the conversation.
    * @returns {boolean}
    */
    get onlyAllowTrustedDevices() {
        const ret = wasm.__wbg_get_encryptionsettings_onlyAllowTrustedDevices(this.ptr);
        return ret !== 0;
    }
    /**
    * Should untrusted devices receive the room key, or should they be
    * excluded from the conversation.
    * @param {boolean} arg0
    */
    set onlyAllowTrustedDevices(arg0) {
        wasm.__wbg_set_encryptionsettings_onlyAllowTrustedDevices(this.ptr, arg0);
    }
    /**
    * Create a new `EncryptionSettings` with default values.
    */
    constructor() {
        const ret = wasm.encryptionsettings_new();
        return EncryptionSettings.__wrap(ret);
    }
}
module.exports.EncryptionSettings = EncryptionSettings;

const EventIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_eventid_free(ptr));
/**
* A Matrix [event ID].
*
* An `EventId` is generated randomly or converted from a string
* slice, and can be converted back into a string as needed.
*
* [event ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
class EventId {

    static __wrap(ptr) {
        const obj = Object.create(EventId.prototype);
        obj.ptr = ptr;
        EventIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        EventIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_eventid_free(ptr);
    }
    /**
    * Parse/validate and create a new `EventId`.
    * @param {string} id
    */
    constructor(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.eventid_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return EventId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the event's localpart.
    * @returns {string}
    */
    get localpart() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.eventid_localpart(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns the server name of the event ID.
    * @returns {ServerName | undefined}
    */
    get serverName() {
        const ret = wasm.eventid_serverName(this.ptr);
        return ret === 0 ? undefined : ServerName.__wrap(ret);
    }
    /**
    * Return the event ID as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.deviceid_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.EventId = EventId;

const IdentityKeysFinalization = new FinalizationRegistry(ptr => wasm.__wbg_identitykeys_free(ptr));
/**
* Struct holding the two public identity keys of an account.
*/
class IdentityKeys {

    static __wrap(ptr) {
        const obj = Object.create(IdentityKeys.prototype);
        obj.ptr = ptr;
        IdentityKeysFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        IdentityKeysFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_identitykeys_free(ptr);
    }
    /**
    * The Ed25519 public key, used for signing.
    * @returns {Ed25519PublicKey}
    */
    get ed25519() {
        const ret = wasm.__wbg_get_identitykeys_ed25519(this.ptr);
        return Ed25519PublicKey.__wrap(ret);
    }
    /**
    * The Ed25519 public key, used for signing.
    * @param {Ed25519PublicKey} arg0
    */
    set ed25519(arg0) {
        _assertClass(arg0, Ed25519PublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_identitykeys_ed25519(this.ptr, ptr0);
    }
    /**
    * The Curve25519 public key, used for establish shared secrets.
    * @returns {Curve25519PublicKey}
    */
    get curve25519() {
        const ret = wasm.__wbg_get_identitykeys_curve25519(this.ptr);
        return Curve25519PublicKey.__wrap(ret);
    }
    /**
    * The Curve25519 public key, used for establish shared secrets.
    * @param {Curve25519PublicKey} arg0
    */
    set curve25519(arg0) {
        _assertClass(arg0, Curve25519PublicKey);
        var ptr0 = arg0.__destroy_into_raw();
        wasm.__wbg_set_identitykeys_curve25519(this.ptr, ptr0);
    }
}
module.exports.IdentityKeys = IdentityKeys;

const InboundGroupSessionFinalization = new FinalizationRegistry(ptr => wasm.__wbg_inboundgroupsession_free(ptr));
/**
* Inbound group session.
*
* Inbound group sessions are used to exchange room messages between a group of
* participants. Inbound group sessions are used to decrypt the room messages.
*/
class InboundGroupSession {

    static __wrap(ptr) {
        const obj = Object.create(InboundGroupSession.prototype);
        obj.ptr = ptr;
        InboundGroupSessionFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        InboundGroupSessionFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_inboundgroupsession_free(ptr);
    }
    /**
    * The room where this session is used in.
    * @returns {RoomId}
    */
    get roomId() {
        const ret = wasm.inboundgroupsession_roomId(this.ptr);
        return RoomId.__wrap(ret);
    }
    /**
    * Returns the unique identifier for this session.
    * @returns {string}
    */
    get sessionId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.inboundgroupsession_sessionId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Has the session been imported from a file or server-side backup? As
    * opposed to being directly received as an `m.room_key` event.
    * @returns {boolean}
    */
    hasBeenImported() {
        const ret = wasm.inboundgroupsession_hasBeenImported(this.ptr);
        return ret !== 0;
    }
}
module.exports.InboundGroupSession = InboundGroupSession;

const KeysBackupRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keysbackuprequest_free(ptr));
/**
* A request that will back up a batch of room keys to the server
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3room_keyskeys
*/
class KeysBackupRequest {

    static __wrap(ptr) {
        const obj = Object.create(KeysBackupRequest.prototype);
        obj.ptr = ptr;
        KeysBackupRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeysBackupRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysbackuprequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `rooms`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `KeysBackupRequest`.
    * @param {string} id
    * @param {string} body
    */
    constructor(id, body) {
        const ret = wasm.keysbackuprequest_new(addHeapObject(id), addHeapObject(body));
        return KeysBackupRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.keysbackuprequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.KeysBackupRequest = KeysBackupRequest;

const KeysClaimRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keysclaimrequest_free(ptr));
/**
* Data for a request to the `/keys/claim` API endpoint
* ([specification]).
*
* Claims one-time keys that can be used to establish 1-to-1 E2EE
* sessions.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysclaim
*/
class KeysClaimRequest {

    static __wrap(ptr) {
        const obj = Object.create(KeysClaimRequest.prototype);
        obj.ptr = ptr;
        KeysClaimRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeysClaimRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysclaimrequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `timeout`,
    * `one_time_keys`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `KeysClaimRequest`.
    * @param {string} id
    * @param {string} body
    */
    constructor(id, body) {
        const ret = wasm.keysbackuprequest_new(addHeapObject(id), addHeapObject(body));
        return KeysClaimRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.keysclaimrequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.KeysClaimRequest = KeysClaimRequest;

const KeysQueryRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keysqueryrequest_free(ptr));
/**
* Data for a request to the `/keys/query` API endpoint
* ([specification]).
*
* Returns the current devices and identity keys for the given users.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysquery
*/
class KeysQueryRequest {

    static __wrap(ptr) {
        const obj = Object.create(KeysQueryRequest.prototype);
        obj.ptr = ptr;
        KeysQueryRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeysQueryRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysqueryrequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `timeout`,
    * `device_keys`, `token`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `KeysQueryRequest`.
    * @param {string} id
    * @param {string} body
    */
    constructor(id, body) {
        const ret = wasm.keysbackuprequest_new(addHeapObject(id), addHeapObject(body));
        return KeysQueryRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.keysqueryrequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.KeysQueryRequest = KeysQueryRequest;

const KeysUploadRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_keysuploadrequest_free(ptr));
/**
* Outgoing Requests *
* Data for a request to the `/keys/upload` API endpoint
* ([specification]).
*
* Publishes end-to-end encryption keys for the device.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysupload
*/
class KeysUploadRequest {

    static __wrap(ptr) {
        const obj = Object.create(KeysUploadRequest.prototype);
        obj.ptr = ptr;
        KeysUploadRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        KeysUploadRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_keysuploadrequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `device_keys`,
    * `one_time_keys`, `fallback_keys`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `KeysUploadRequest`.
    * @param {string} id
    * @param {string} body
    */
    constructor(id, body) {
        const ret = wasm.keysbackuprequest_new(addHeapObject(id), addHeapObject(body));
        return KeysUploadRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.keysuploadrequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.KeysUploadRequest = KeysUploadRequest;

const MaybeSignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_maybesignature_free(ptr));
/**
* Represents a signature that is either valid _or_ that could not be
* decoded.
*/
class MaybeSignature {

    static __wrap(ptr) {
        const obj = Object.create(MaybeSignature.prototype);
        obj.ptr = ptr;
        MaybeSignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        MaybeSignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_maybesignature_free(ptr);
    }
    /**
    * Check whether the signature has been successfully decoded.
    * @returns {boolean}
    */
    isValid() {
        const ret = wasm.maybesignature_isValid(this.ptr);
        return ret !== 0;
    }
    /**
    * Check whether the signature could not be successfully decoded.
    * @returns {boolean}
    */
    isInvalid() {
        const ret = wasm.maybesignature_isInvalid(this.ptr);
        return ret !== 0;
    }
    /**
    * The signature, if successfully decoded.
    * @returns {Signature | undefined}
    */
    get signature() {
        const ret = wasm.maybesignature_signature(this.ptr);
        return ret === 0 ? undefined : Signature.__wrap(ret);
    }
    /**
    * The base64 encoded string that is claimed to contain a
    * signature but could not be decoded, if any.
    * @returns {string | undefined}
    */
    get invalidSignatureSource() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.maybesignature_invalidSignatureSource(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.MaybeSignature = MaybeSignature;

const OlmMachineFinalization = new FinalizationRegistry(ptr => wasm.__wbg_olmmachine_free(ptr));
/**
* State machine implementation of the Olm/Megolm encryption protocol
* used for Matrix end to end encryption.
*/
class OlmMachine {

    static __wrap(ptr) {
        const obj = Object.create(OlmMachine.prototype);
        obj.ptr = ptr;
        OlmMachineFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        OlmMachineFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_olmmachine_free(ptr);
    }
    /**
    * Constructor will always fail. To create a new `OlmMachine`, please use
    * the `initialize` method.
    *
    * Why this pattern? `initialize` returns a `Promise`. Returning a
    */
    constructor() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.olmmachine_new(retptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return OlmMachine.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Create a new `OlmMachine`.
    *
    * The created machine will keep the encryption keys either in a IndexedDB
    * based store, or in a memory store and once the objects is dropped,
    * the keys will be lost.
    *
    * # Arguments
    *
    * * `user_id` - represents the unique ID of the user that owns this
    * machine.
    *
    * * `device_id` - represents the unique ID of the device
    * that owns this machine.
    *
    * * `store_name` - The name that should be used to open the IndexedDB
    *   based database. If this isn't provided, a memory-only store will be
    *   used. *Note* the memory-only store will lose your E2EE keys when the
    *   `OlmMachine` gets dropped.
    *
    * * `store_passphrase` - The passphrase that should be used to encrypt the
    *   IndexedDB based
    * @param {UserId} user_id
    * @param {DeviceId} device_id
    * @param {string | undefined} store_name
    * @param {string | undefined} store_passphrase
    * @returns {Promise<any>}
    */
    static initialize(user_id, device_id, store_name, store_passphrase) {
        _assertClass(user_id, UserId);
        _assertClass(device_id, DeviceId);
        var ptr0 = isLikeNone(store_name) ? 0 : passStringToWasm0(store_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(store_passphrase) ? 0 : passStringToWasm0(store_passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len1 = WASM_VECTOR_LEN;
        const ret = wasm.olmmachine_initialize(user_id.ptr, device_id.ptr, ptr0, len0, ptr1, len1);
        return takeObject(ret);
    }
    /**
    * The unique user ID that owns this `OlmMachine` instance.
    * @returns {UserId}
    */
    get userId() {
        const ret = wasm.olmmachine_userId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * The unique device ID that identifies this `OlmMachine`.
    * @returns {DeviceId}
    */
    get deviceId() {
        const ret = wasm.olmmachine_deviceId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Get the public parts of our Olm identity keys.
    * @returns {IdentityKeys}
    */
    get identityKeys() {
        const ret = wasm.olmmachine_identityKeys(this.ptr);
        return IdentityKeys.__wrap(ret);
    }
    /**
    * Get the display name of our own device.
    * @returns {Promise<any>}
    */
    get displayName() {
        const ret = wasm.olmmachine_displayName(this.ptr);
        return takeObject(ret);
    }
    /**
    * Get the list of users whose devices we are currently tracking.
    *
    * A user can be marked for tracking using the
    * [`update_tracked_users`](#method.update_tracked_users) method.
    *
    * Returns a `Set<UserId>`.
    * @returns {Promise<any>}
    */
    trackedUsers() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.olmmachine_trackedUsers(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Update the list of tracked users.
    *
    * The OlmMachine maintains a list of users whose devices we are keeping
    * track of: these are known as "tracked users". These must be users
    * that we share a room with, so that the server sends us updates for
    * their device lists.
    *
    * # Arguments
    *
    * * `users` - An array of user ids that should be added to the list of
    *   tracked users
    *
    * Any users that hadn't been seen before will be flagged for a key query
    * immediately, and whenever `receive_sync_changes` receives a
    * "changed" notification for that user in the future.
    *
    * Users that were already in the list are unaffected.
    * @param {Array<any>} users
    * @returns {Promise<any>}
    */
    updateTrackedUsers(users) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.olmmachine_updateTrackedUsers(retptr, this.ptr, addBorrowedObject(users));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Handle to-device events and one-time key counts from a sync
    * response.
    *
    * This will decrypt and handle to-device events returning the
    * decrypted versions of them.
    *
    * To decrypt an event from the room timeline call
    * `decrypt_room_event`.
    * @param {string} to_device_events
    * @param {DeviceLists} changed_devices
    * @param {Map<any, any>} one_time_key_counts
    * @param {Set<any>} unused_fallback_keys
    * @returns {Promise<any>}
    */
    receiveSyncChanges(to_device_events, changed_devices, one_time_key_counts, unused_fallback_keys) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(to_device_events, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(changed_devices, DeviceLists);
            wasm.olmmachine_receiveSyncChanges(retptr, this.ptr, ptr0, len0, changed_devices.ptr, addBorrowedObject(one_time_key_counts), addBorrowedObject(unused_fallback_keys));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Get the outgoing requests that need to be sent out.
    *
    * This returns a list of `JsValue` to represent either:
    *   * `KeysUploadRequest`,
    *   * `KeysQueryRequest`,
    *   * `KeysClaimRequest`,
    *   * `ToDeviceRequest`,
    *   * `SignatureUploadRequest`,
    *   * `RoomMessageRequest` or
    *   * `KeysBackupRequest`.
    *
    * Those requests need to be sent out to the server and the
    * responses need to be passed back to the state machine using
    * `mark_request_as_sent`.
    * @returns {Promise<any>}
    */
    outgoingRequests() {
        const ret = wasm.olmmachine_outgoingRequests(this.ptr);
        return takeObject(ret);
    }
    /**
    * Mark the request with the given request ID as sent (see
    * `outgoing_requests`).
    *
    * Arguments are:
    *
    * * `request_id` represents the unique ID of the request that was sent
    *   out. This is needed to couple the response with the now sent out
    *   request.
    * * `response_type` represents the type of the request that was sent out.
    * * `response` represents the response that was received from the server
    *   after the outgoing request was sent out.
    * @param {string} request_id
    * @param {number} request_type
    * @param {string} response
    * @returns {Promise<any>}
    */
    markRequestAsSent(request_id, request_type, response) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(request_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(response, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.olmmachine_markRequestAsSent(retptr, this.ptr, ptr0, len0, request_type, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Encrypt a room message for the given room.
    *
    * Beware that a room key needs to be shared before this
    * method can be called using the `share_room_key` method.
    *
    * `room_id` is the ID of the room for which the message should
    * be encrypted. `event_type` is the type of the event. `content`
    * is the plaintext content of the message that should be
    * encrypted.
    *
    * # Panics
    *
    * Panics if a group session for the given room wasn't shared
    * beforehand.
    * @param {RoomId} room_id
    * @param {string} event_type
    * @param {string} content
    * @returns {Promise<any>}
    */
    encryptRoomEvent(room_id, event_type, content) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(room_id, RoomId);
            const ptr0 = passStringToWasm0(event_type, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(content, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.olmmachine_encryptRoomEvent(retptr, this.ptr, room_id.ptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Decrypt an event from a room timeline.
    *
    * # Arguments
    *
    * * `event`, the event that should be decrypted.
    * * `room_id`, the ID of the room where the event was sent to.
    * @param {string} event
    * @param {RoomId} room_id
    * @returns {Promise<any>}
    */
    decryptRoomEvent(event, room_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(event, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(room_id, RoomId);
            wasm.olmmachine_decryptRoomEvent(retptr, this.ptr, ptr0, len0, room_id.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get the status of the private cross signing keys.
    *
    * This can be used to check which private cross signing keys we
    * have stored locally.
    * @returns {Promise<any>}
    */
    crossSigningStatus() {
        const ret = wasm.olmmachine_crossSigningStatus(this.ptr);
        return takeObject(ret);
    }
    /**
    * Export all the private cross signing keys we have.
    *
    * The export will contain the seed for the ed25519 keys as a
    * unpadded base64 encoded string.
    *
    * This method returns None if we don’t have any private cross
    * signing keys.
    * @returns {Promise<any>}
    */
    exportCrossSigningKeys() {
        const ret = wasm.olmmachine_exportCrossSigningKeys(this.ptr);
        return takeObject(ret);
    }
    /**
    * Import our private cross signing keys.
    *
    * The export needs to contain the seed for the ed25519 keys as
    * an unpadded base64 encoded string.
    * @param {CrossSigningKeyExport} _export
    * @returns {Promise<any>}
    */
    importCrossSigningKeys(_export) {
        _assertClass(_export, CrossSigningKeyExport);
        var ptr0 = _export.__destroy_into_raw();
        const ret = wasm.olmmachine_importCrossSigningKeys(this.ptr, ptr0);
        return takeObject(ret);
    }
    /**
    * Create a new cross signing identity and get the upload request
    * to push the new public keys to the server.
    *
    * Warning: This will delete any existing cross signing keys that
    * might exist on the server and thus will reset the trust
    * between all the devices.
    *
    * Uploading these keys will require user interactive auth.
    * @param {boolean} reset
    * @returns {Promise<any>}
    */
    bootstrapCrossSigning(reset) {
        const ret = wasm.olmmachine_bootstrapCrossSigning(this.ptr, reset);
        return takeObject(ret);
    }
    /**
    * Get the cross signing user identity of a user.
    * @param {UserId} user_id
    * @returns {Promise<any>}
    */
    getIdentity(user_id) {
        _assertClass(user_id, UserId);
        const ret = wasm.olmmachine_getIdentity(this.ptr, user_id.ptr);
        return takeObject(ret);
    }
    /**
    * Sign the given message using our device key and if available
    * cross-signing master key.
    * @param {string} message
    * @returns {Promise<any>}
    */
    sign(message) {
        const ptr0 = passStringToWasm0(message, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.olmmachine_sign(this.ptr, ptr0, len0);
        return takeObject(ret);
    }
    /**
    * Invalidate the currently active outbound group session for the
    * given room.
    *
    * Returns true if a session was invalidated, false if there was
    * no session to invalidate.
    * @param {RoomId} room_id
    * @returns {Promise<any>}
    */
    invalidateGroupSession(room_id) {
        _assertClass(room_id, RoomId);
        const ret = wasm.olmmachine_invalidateGroupSession(this.ptr, room_id.ptr);
        return takeObject(ret);
    }
    /**
    * Get to-device requests to share a room key with users in a room.
    *
    * `room_id` is the room ID. `users` is an array of `UserId`
    * objects. `encryption_settings` are an `EncryptionSettings`
    * object.
    *
    * Returns an array of `ToDeviceRequest`s.
    * @param {RoomId} room_id
    * @param {Array<any>} users
    * @param {EncryptionSettings} encryption_settings
    * @returns {Promise<any>}
    */
    shareRoomKey(room_id, users, encryption_settings) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(room_id, RoomId);
            _assertClass(encryption_settings, EncryptionSettings);
            wasm.olmmachine_shareRoomKey(retptr, this.ptr, room_id.ptr, addBorrowedObject(users), encryption_settings.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Get the a key claiming request for the user/device pairs that
    * we are missing Olm sessions for.
    *
    * Returns `null` if no key claiming request needs to be sent
    * out, otherwise it returns a `KeysClaimRequest` object.
    *
    * Sessions need to be established between devices so group
    * sessions for a room can be shared with them.
    *
    * This should be called every time a group session needs to be
    * shared as well as between sync calls. After a sync some
    * devices may request room keys without us having a valid Olm
    * session with them, making it impossible to server the room key
    * request, thus it’s necessary to check for missing sessions
    * between sync as well.
    *
    * Note: Care should be taken that only one such request at a
    * time is in flight, e.g. using a lock.
    *
    * The response of a successful key claiming requests needs to be
    * passed to the `OlmMachine` with the `mark_request_as_sent`.
    *
    * `users` represents the list of users that we should check if
    * we lack a session with one of their devices. This can be an
    * empty iterator when calling this method between sync requests.
    * @param {Array<any>} users
    * @returns {Promise<any>}
    */
    getMissingSessions(users) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.olmmachine_getMissingSessions(retptr, this.ptr, addBorrowedObject(users));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
    /**
    * Get a map holding all the devices of a user.
    *
    * `user_id` represents the unique ID of the user that the
    * devices belong to.
    * @param {UserId} user_id
    * @returns {Promise<any>}
    */
    getUserDevices(user_id) {
        _assertClass(user_id, UserId);
        const ret = wasm.olmmachine_getUserDevices(this.ptr, user_id.ptr);
        return takeObject(ret);
    }
    /**
    * Get a specific device of a user if one is found and the crypto store
    * didn't throw an error.
    *
    * `user_id` represents the unique ID of the user that the
    * identity belongs to. `device_id` represents the unique ID of
    * the device.
    * @param {UserId} user_id
    * @param {DeviceId} device_id
    * @returns {Promise<any>}
    */
    getDevice(user_id, device_id) {
        _assertClass(user_id, UserId);
        _assertClass(device_id, DeviceId);
        const ret = wasm.olmmachine_getDevice(this.ptr, user_id.ptr, device_id.ptr);
        return takeObject(ret);
    }
    /**
    * Get a verification object for the given user ID with the given
    * flow ID (a to-device request ID if the verification has been
    * requested by a to-device request, or a room event ID if the
    * verification has been requested by a room event).
    *
    * It returns a “`Verification` object”, which is either a `Sas`
    * or `Qr` object.
    * @param {UserId} user_id
    * @param {string} flow_id
    * @returns {any}
    */
    getVerification(user_id, flow_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(user_id, UserId);
            const ptr0 = passStringToWasm0(flow_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.olmmachine_getVerification(retptr, this.ptr, user_id.ptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get a verification request object with the given flow ID.
    * @param {UserId} user_id
    * @param {string} flow_id
    * @returns {VerificationRequest | undefined}
    */
    getVerificationRequest(user_id, flow_id) {
        _assertClass(user_id, UserId);
        const ptr0 = passStringToWasm0(flow_id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len0 = WASM_VECTOR_LEN;
        const ret = wasm.olmmachine_getVerificationRequest(this.ptr, user_id.ptr, ptr0, len0);
        return ret === 0 ? undefined : VerificationRequest.__wrap(ret);
    }
    /**
    * Get all the verification requests of a given user.
    * @param {UserId} user_id
    * @returns {Array<any>}
    */
    getVerificationRequests(user_id) {
        _assertClass(user_id, UserId);
        const ret = wasm.olmmachine_getVerificationRequests(this.ptr, user_id.ptr);
        return takeObject(ret);
    }
    /**
    * Receive a verification event.
    *
    * This method can be used to pass verification events that are happening
    * in rooms to the `OlmMachine`. The event should be in the decrypted form.
    * @param {string} event
    * @param {RoomId} room_id
    * @returns {Promise<any>}
    */
    receiveVerificationEvent(event, room_id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(event, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            _assertClass(room_id, RoomId);
            wasm.olmmachine_receiveVerificationEvent(retptr, this.ptr, ptr0, len0, room_id.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Export the keys that match the given predicate.
    *
    * `predicate` is a closure that will be called for every known
    * `InboundGroupSession`, which represents a room key. If the closure
    * returns `true`, the `InboundGroupSession` will be included in the
    * export, otherwise it won't.
    * @param {Function} predicate
    * @returns {Promise<any>}
    */
    exportRoomKeys(predicate) {
        const ret = wasm.olmmachine_exportRoomKeys(this.ptr, addHeapObject(predicate));
        return takeObject(ret);
    }
    /**
    * Import the given room keys into our store.
    *
    * `exported_keys` is a list of previously exported keys that should be
    * imported into our store. If we already have a better version of a key,
    * the key will _not_ be imported.
    *
    * `progress_listener` is a closure that takes 2 arguments: `progress` and
    * `total`, and returns nothing.
    * @param {string} exported_room_keys
    * @param {Function} progress_listener
    * @returns {Promise<any>}
    */
    importRoomKeys(exported_room_keys, progress_listener) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.olmmachine_importRoomKeys(retptr, this.ptr, ptr0, len0, addHeapObject(progress_listener));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Encrypt the list of exported room keys using the given passphrase.
    *
    * `exported_room_keys` is a list of sessions that should be encrypted
    * (it's generally returned by `export_room_keys`). `passphrase` is the
    * passphrase that will be used to encrypt the exported room keys. And
    * `rounds` is the number of rounds that should be used for the key
    * derivation when the passphrase gets turned into an AES key. More rounds
    * are increasingly computationnally intensive and as such help against
    * brute-force attacks. Should be at least `10_000`, while values in the
    * `100_000` ranges should be preferred.
    * @param {string} exported_room_keys
    * @param {string} passphrase
    * @param {number} rounds
    * @returns {string}
    */
    static encryptExportedRoomKeys(exported_room_keys, passphrase, rounds) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.olmmachine_encryptExportedRoomKeys(retptr, ptr0, len0, ptr1, len1, rounds);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr2 = r0;
            var len2 = r1;
            if (r3) {
                ptr2 = 0; len2 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr2, len2);
        }
    }
    /**
    * Try to decrypt a reader into a list of exported room keys.
    *
    * `encrypted_exported_room_keys` is the result from
    * `encrypt_exported_room_keys`. `passphrase` is the passphrase that was
    * used when calling `encrypt_exported_room_keys`.
    * @param {string} encrypted_exported_room_keys
    * @param {string} passphrase
    * @returns {string}
    */
    static decryptExportedRoomKeys(encrypted_exported_room_keys, passphrase) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(encrypted_exported_room_keys, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            const ptr1 = passStringToWasm0(passphrase, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len1 = WASM_VECTOR_LEN;
            wasm.olmmachine_decryptExportedRoomKeys(retptr, ptr0, len0, ptr1, len1);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr2 = r0;
            var len2 = r1;
            if (r3) {
                ptr2 = 0; len2 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr2, len2);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr2, len2);
        }
    }
    /**
    * Shut down the `OlmMachine`.
    *
    * The `OlmMachine` cannot be used after this method has been called.
    *
    * All associated resources will be closed too, like IndexedDB
    * connections.
    */
    close() {
        const ptr = this.__destroy_into_raw();
        wasm.olmmachine_close(ptr);
    }
}
module.exports.OlmMachine = OlmMachine;

const OwnUserIdentityFinalization = new FinalizationRegistry(ptr => wasm.__wbg_ownuseridentity_free(ptr));
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that is our own.
*/
class OwnUserIdentity {

    static __wrap(ptr) {
        const obj = Object.create(OwnUserIdentity.prototype);
        obj.ptr = ptr;
        OwnUserIdentityFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        OwnUserIdentityFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_ownuseridentity_free(ptr);
    }
    /**
    * Mark our user identity as verified.
    *
    * This will mark the identity locally as verified and sign it with our own
    * device.
    *
    * Returns a signature upload request that needs to be sent out.
    * @returns {Promise<any>}
    */
    verify() {
        const ret = wasm.ownuseridentity_verify(this.ptr);
        return takeObject(ret);
    }
    /**
    * Send a verification request to our other devices.
    * @param {Array<any> | undefined} methods
    * @returns {Promise<any>}
    */
    requestVerification(methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.ownuseridentity_requestVerification(retptr, this.ptr, isLikeNone(methods) ? 0 : addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Does our user identity trust our own device, i.e. have we signed our own
    * device keys with our self-signing key?
    * @returns {Promise<any>}
    */
    trustsOurOwnDevice() {
        const ret = wasm.ownuseridentity_trustsOurOwnDevice(this.ptr);
        return takeObject(ret);
    }
}
module.exports.OwnUserIdentity = OwnUserIdentity;

const QrFinalization = new FinalizationRegistry(ptr => wasm.__wbg_qr_free(ptr));
/**
* QR code based verification.
*/
class Qr {

    static __wrap(ptr) {
        const obj = Object.create(Qr.prototype);
        obj.ptr = ptr;
        QrFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        QrFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_qr_free(ptr);
    }
    /**
    * Has the QR verification been scanned by the other side.
    *
    * When the verification object is in this state it’s required
    * that the user confirms that the other side has scanned the QR
    * code.
    * @returns {boolean}
    */
    hasBeenScanned() {
        const ret = wasm.qr_hasBeenScanned(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the scanning of the QR code been confirmed by us.
    * @returns {boolean}
    */
    hasBeenConfirmed() {
        const ret = wasm.qr_hasBeenConfirmed(this.ptr);
        return ret !== 0;
    }
    /**
    * Get our own user ID.
    * @returns {UserId}
    */
    get userId() {
        const ret = wasm.qr_userId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * Get the user id of the other user that is participating in
    * this verification flow.
    * @returns {UserId}
    */
    get otherUserId() {
        const ret = wasm.qr_otherUserId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * Get the device ID of the other side.
    * @returns {DeviceId}
    */
    get otherDeviceId() {
        const ret = wasm.qr_otherDeviceId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Did we initiate the verification request.
    * @returns {boolean}
    */
    weStarted() {
        const ret = wasm.qr_weStarted(this.ptr);
        return ret !== 0;
    }
    /**
    * Get info about the cancellation if the verification flow has
    * been cancelled.
    * @returns {CancelInfo | undefined}
    */
    cancelInfo() {
        const ret = wasm.qr_cancelInfo(this.ptr);
        return ret === 0 ? undefined : CancelInfo.__wrap(ret);
    }
    /**
    * Has the verification flow completed.
    * @returns {boolean}
    */
    isDone() {
        const ret = wasm.qr_isDone(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the verification flow been cancelled.
    * @returns {boolean}
    */
    isCancelled() {
        const ret = wasm.qr_isCancelled(this.ptr);
        return ret !== 0;
    }
    /**
    * Is this a verification that is veryfying one of our own devices.
    * @returns {boolean}
    */
    isSelfVerification() {
        const ret = wasm.qr_isSelfVerification(this.ptr);
        return ret !== 0;
    }
    /**
    * Have we successfully scanned the QR code and are able to send
    * a reciprocation event.
    * @returns {boolean}
    */
    reciprocated() {
        const ret = wasm.qr_reciprocated(this.ptr);
        return ret !== 0;
    }
    /**
    * Get the unique ID that identifies this QR verification flow,
    * be either a to-device request ID or a room event ID.
    * @returns {string}
    */
    get flowId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_flowId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Get the room id if the verification is happening inside a
    * room.
    * @returns {RoomId | undefined}
    */
    get roomId() {
        const ret = wasm.qr_roomId(this.ptr);
        return ret === 0 ? undefined : RoomId.__wrap(ret);
    }
    /**
    * Generate a QR code object that is representing this
    * verification flow.
    *
    * The QrCode can then be rendered as an image or as an unicode
    * string.
    *
    * The `to_bytes` method can be used to instead output the raw
    * bytes that should be encoded as a QR code.
    * @returns {QrCode}
    */
    toQrCode() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_toQrCode(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return QrCode.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Generate a the raw bytes that should be encoded as a QR code
    * is representing this verification flow.
    *
    * The `to_qr_code` method can be used to instead output a QrCode
    * object that can be rendered.
    * @returns {Uint8ClampedArray}
    */
    toBytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_toBytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Notify the other side that we have successfully scanned the QR
    * code and that the QR verification flow can start.
    *
    * This will return some OutgoingContent if the object is in the
    * correct state to start the verification flow, otherwise None.
    * @returns {any}
    */
    reciprocate() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_reciprocate(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Confirm that the other side has scanned our QR code.
    * @returns {any}
    */
    confirmScanning() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_confirmScanning(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Cancel the verification flow.
    * @returns {any}
    */
    cancel() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_cancel(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Cancel the verification.
    *
    * This cancels the verification with given code.
    * @param {number} code
    * @returns {any}
    */
    cancelWithCode(code) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qr_cancelWithCode(retptr, this.ptr, code);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.Qr = Qr;

const QrCodeFinalization = new FinalizationRegistry(ptr => wasm.__wbg_qrcode_free(ptr));
/**
* A QR code.
*/
class QrCode {

    static __wrap(ptr) {
        const obj = Object.create(QrCode.prototype);
        obj.ptr = ptr;
        QrCodeFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        QrCodeFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_qrcode_free(ptr);
    }
    /**
    * Render the QR code into a `Uint8ClampedArray` where 1 represents a
    * dark pixel and 0 a white pixel.
    * @returns {Uint8ClampedArray}
    */
    renderIntoBuffer() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qrcode_renderIntoBuffer(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.QrCode = QrCode;

const QrCodeScanFinalization = new FinalizationRegistry(ptr => wasm.__wbg_qrcodescan_free(ptr));
/**
* A scanned QR code.
*/
class QrCodeScan {

    static __wrap(ptr) {
        const obj = Object.create(QrCodeScan.prototype);
        obj.ptr = ptr;
        QrCodeScanFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        QrCodeScanFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_qrcodescan_free(ptr);
    }
    /**
    * Parse the decoded payload of a QR code in byte slice form.
    *
    * This method is useful if you would like to do your own custom QR code
    * decoding.
    * @param {Uint8ClampedArray} buffer
    * @returns {QrCodeScan}
    */
    static fromBytes(buffer) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.qrcodescan_fromBytes(retptr, addBorrowedObject(buffer));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return QrCodeScan.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            heap[stack_pointer++] = undefined;
        }
    }
}
module.exports.QrCodeScan = QrCodeScan;

const RoomIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_roomid_free(ptr));
/**
* A Matrix [room ID].
*
* [room ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
class RoomId {

    static __wrap(ptr) {
        const obj = Object.create(RoomId.prototype);
        obj.ptr = ptr;
        RoomIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RoomIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_roomid_free(ptr);
    }
    /**
    * Parse/validate and create a new `RoomId`.
    * @param {string} id
    */
    constructor(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.roomid_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return RoomId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the user's localpart.
    * @returns {string}
    */
    get localpart() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.roomid_localpart(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns the server name of the room ID.
    * @returns {ServerName}
    */
    get serverName() {
        const ret = wasm.roomid_serverName(this.ptr);
        return ServerName.__wrap(ret);
    }
    /**
    * Return the room ID as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.deviceid_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.RoomId = RoomId;

const RoomMessageRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_roommessagerequest_free(ptr));
/**
* A customized owned request type for sending out room messages
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid
*/
class RoomMessageRequest {

    static __wrap(ptr) {
        const obj = Object.create(RoomMessageRequest.prototype);
        obj.ptr = ptr;
        RoomMessageRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        RoomMessageRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_roommessagerequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A string representing the room to send the event to.
    * @returns {string}
    */
    get room_id() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * A string representing the transaction ID for this event.
    *
    * Clients should generate an ID unique across requests with the same
    * access token; it will be used by the server to ensure idempotency of
    * requests.
    * @returns {string}
    */
    get txn_id() {
        const ret = wasm.__wbg_get_roommessagerequest_txn_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A string representing the type of event to be sent.
    * @returns {string}
    */
    get event_type() {
        const ret = wasm.__wbg_get_roommessagerequest_event_type(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the message's content.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_roommessagerequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `RoomMessageRequest`.
    * @param {string} id
    * @param {string} room_id
    * @param {string} txn_id
    * @param {string} event_type
    * @param {string} content
    */
    constructor(id, room_id, txn_id, event_type, content) {
        const ret = wasm.roommessagerequest_new(addHeapObject(id), addHeapObject(room_id), addHeapObject(txn_id), addHeapObject(event_type), addHeapObject(content));
        return RoomMessageRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.roommessagerequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.RoomMessageRequest = RoomMessageRequest;

const SasFinalization = new FinalizationRegistry(ptr => wasm.__wbg_sas_free(ptr));
/**
* Short Authentication String (SAS) verification.
*/
class Sas {

    static __wrap(ptr) {
        const obj = Object.create(Sas.prototype);
        obj.ptr = ptr;
        SasFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SasFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_sas_free(ptr);
    }
    /**
    * Get our own user ID.
    * @returns {UserId}
    */
    get userId() {
        const ret = wasm.sas_userId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * Get our own device ID.
    * @returns {DeviceId}
    */
    get deviceId() {
        const ret = wasm.inboundgroupsession_roomId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Get the user id of the other side.
    * @returns {UserId}
    */
    get otherUserId() {
        const ret = wasm.sas_otherUserId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * Get the device ID of the other side.
    * @returns {DeviceId}
    */
    get otherDeviceId() {
        const ret = wasm.sas_otherDeviceId(this.ptr);
        return DeviceId.__wrap(ret);
    }
    /**
    * Get the unique ID that identifies this SAS verification flow,
    * be either a to-device request ID or a room event ID.
    * @returns {string}
    */
    get flowId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sas_flowId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Get the room ID if the verification is happening inside a
    * room.
    * @returns {RoomId | undefined}
    */
    get roomId() {
        const ret = wasm.sas_roomId(this.ptr);
        return ret === 0 ? undefined : RoomId.__wrap(ret);
    }
    /**
    * Does this verification flow support displaying emoji for the
    * short authentication string.
    * @returns {boolean}
    */
    supportsEmoji() {
        const ret = wasm.sas_supportsEmoji(this.ptr);
        return ret !== 0;
    }
    /**
    * Did this verification flow start from a verification request.
    * @returns {boolean}
    */
    startedFromRequest() {
        const ret = wasm.sas_startedFromRequest(this.ptr);
        return ret !== 0;
    }
    /**
    * Is this a verification that is veryfying one of our own
    * devices.
    * @returns {boolean}
    */
    isSelfVerification() {
        const ret = wasm.sas_isSelfVerification(this.ptr);
        return ret !== 0;
    }
    /**
    * Have we confirmed that the short auth string matches.
    * @returns {boolean}
    */
    haveWeConfirmed() {
        const ret = wasm.sas_haveWeConfirmed(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the verification been accepted by both parties.
    * @returns {boolean}
    */
    hasBeenAccepted() {
        const ret = wasm.sas_hasBeenAccepted(this.ptr);
        return ret !== 0;
    }
    /**
    * Get info about the cancellation if the verification flow has
    * been cancelled.
    * @returns {CancelInfo | undefined}
    */
    cancelInfo() {
        const ret = wasm.sas_cancelInfo(this.ptr);
        return ret === 0 ? undefined : CancelInfo.__wrap(ret);
    }
    /**
    * Did we initiate the verification flow.
    * @returns {boolean}
    */
    weStarted() {
        const ret = wasm.sas_weStarted(this.ptr);
        return ret !== 0;
    }
    /**
    * Accept the SAS verification.
    *
    * This does nothing if the verification was already accepted,
    * otherwise it returns an `AcceptEventContent` that needs to be
    * sent out.
    * @returns {any}
    */
    accept() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sas_accept(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Confirm the SAS verification.
    *
    * This confirms that the short auth strings match on both sides.
    *
    * Does nothing if we’re not in a state where we can confirm the
    * short auth string, otherwise returns a `MacEventContent` that
    * needs to be sent to the server.
    * @returns {Promise<any>}
    */
    confirm() {
        const ret = wasm.sas_confirm(this.ptr);
        return takeObject(ret);
    }
    /**
    * Cancel the verification.
    * @returns {any}
    */
    cancel() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sas_cancel(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Cancel the verification.
    *
    * This cancels the verification with given code.
    * @param {number} code
    * @returns {any}
    */
    cancelWithCode(code) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sas_cancelWithCode(retptr, this.ptr, code);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Has the SAS verification flow timed out.
    * @returns {boolean}
    */
    timedOut() {
        const ret = wasm.sas_timedOut(this.ptr);
        return ret !== 0;
    }
    /**
    * Are we in a state where we can show the short auth string.
    * @returns {boolean}
    */
    canBePresented() {
        const ret = wasm.sas_canBePresented(this.ptr);
        return ret !== 0;
    }
    /**
    * Is the SAS flow done.
    * @returns {boolean}
    */
    isDone() {
        const ret = wasm.sas_isDone(this.ptr);
        return ret !== 0;
    }
    /**
    * Is the SAS flow canceled.
    * @returns {boolean}
    */
    isCancelled() {
        const ret = wasm.sas_isCancelled(this.ptr);
        return ret !== 0;
    }
    /**
    * Get the emoji version of the short auth string.
    *
    * Returns `undefined` if we can't yet present the short auth string,
    * otherwise seven tuples containing the emoji and description.
    * @returns {Array<any> | undefined}
    */
    emoji() {
        const ret = wasm.sas_emoji(this.ptr);
        return takeObject(ret);
    }
    /**
    * Get the index of the emoji representing the short auth string
    *
    * Returns `undefined` if we can’t yet present the short auth
    * string, otherwise seven `u8` numbers in the range from 0 to 63
    * inclusive which can be converted to an emoji using [the
    * relevant specification
    * entry](https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji).
    * @returns {Array<any> | undefined}
    */
    emojiIndex() {
        const ret = wasm.sas_emojiIndex(this.ptr);
        return takeObject(ret);
    }
    /**
    * Get the decimal version of the short auth string.
    *
    * Returns None if we can’t yet present the short auth string,
    * otherwise a tuple containing three 4-digit integers that
    * represent the short auth string.
    * @returns {Array<any> | undefined}
    */
    decimals() {
        const ret = wasm.sas_decimals(this.ptr);
        return takeObject(ret);
    }
}
module.exports.Sas = Sas;

const ServerNameFinalization = new FinalizationRegistry(ptr => wasm.__wbg_servername_free(ptr));
/**
* A Matrix-spec compliant [server name].
*
* It consists of a host and an optional port (separated by a colon if
* present).
*
* [server name]: https://spec.matrix.org/v1.2/appendices/#server-name
*/
class ServerName {

    static __wrap(ptr) {
        const obj = Object.create(ServerName.prototype);
        obj.ptr = ptr;
        ServerNameFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ServerNameFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_servername_free(ptr);
    }
    /**
    * Parse/validate and create a new `ServerName`.
    * @param {string} name
    */
    constructor(name) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.servername_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return ServerName.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the host of the server name.
    *
    * That is: Return the part of the server before `:<port>` or the
    * full server name if there is no port.
    * @returns {string}
    */
    get host() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.servername_host(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns the port of the server name if any.
    * @returns {number | undefined}
    */
    get port() {
        const ret = wasm.servername_port(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
    /**
    * Returns true if and only if the server name is an IPv4 or IPv6
    * address.
    * @returns {boolean}
    */
    isIpLiteral() {
        const ret = wasm.servername_isIpLiteral(this.ptr);
        return ret !== 0;
    }
}
module.exports.ServerName = ServerName;

const ShieldStateFinalization = new FinalizationRegistry(ptr => wasm.__wbg_shieldstate_free(ptr));
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
class ShieldState {

    static __wrap(ptr) {
        const obj = Object.create(ShieldState.prototype);
        obj.ptr = ptr;
        ShieldStateFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ShieldStateFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_shieldstate_free(ptr);
    }
    /**
    * The shield color
    * @returns {number}
    */
    get color() {
        const ret = wasm.__wbg_get_shieldstate_color(this.ptr);
        return ret >>> 0;
    }
    /**
    * The shield color
    * @param {number} arg0
    */
    set color(arg0) {
        wasm.__wbg_set_shieldstate_color(this.ptr, arg0);
    }
    /**
    * Error message that can be displayed as a tooltip
    * @returns {string | undefined}
    */
    get message() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.shieldstate_message(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.ShieldState = ShieldState;

const SignatureFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signature_free(ptr));
/**
* Represents a potentially decoded signature (but not a validated
* one).
*/
class Signature {

    static __wrap(ptr) {
        const obj = Object.create(Signature.prototype);
        obj.ptr = ptr;
        SignatureFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SignatureFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signature_free(ptr);
    }
    /**
    * Get the Ed25519 signature, if this is one.
    * @returns {Ed25519Signature | undefined}
    */
    get ed25519() {
        const ret = wasm.signature_ed25519(this.ptr);
        return ret === 0 ? undefined : Ed25519Signature.__wrap(ret);
    }
    /**
    * Convert the signature to a base64 encoded string.
    * @returns {string}
    */
    toBase64() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.signature_toBase64(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.Signature = Signature;

const SignatureUploadRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signatureuploadrequest_free(ptr));
/**
* Data for a request to the `/keys/signatures/upload` API endpoint
* ([specification]).
*
* Publishes cross-signing signatures for the user.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keyssignaturesupload
*/
class SignatureUploadRequest {

    static __wrap(ptr) {
        const obj = Object.create(SignatureUploadRequest.prototype);
        obj.ptr = ptr;
        SignatureUploadRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SignatureUploadRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signatureuploadrequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `signed_keys`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `SignatureUploadRequest`.
    * @param {string} id
    * @param {string} body
    */
    constructor(id, body) {
        const ret = wasm.keysbackuprequest_new(addHeapObject(id), addHeapObject(body));
        return SignatureUploadRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.signatureuploadrequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.SignatureUploadRequest = SignatureUploadRequest;

const SignaturesFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signatures_free(ptr));
/**
* A collection of `Signature`.
*/
class Signatures {

    static __wrap(ptr) {
        const obj = Object.create(Signatures.prototype);
        obj.ptr = ptr;
        SignaturesFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SignaturesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signatures_free(ptr);
    }
    /**
    * Creates a new, empty, signatures collection.
    */
    constructor() {
        const ret = wasm.signatures_new();
        return Signatures.__wrap(ret);
    }
    /**
    * Add the given signature from the given signer and the given key ID to
    * the collection.
    * @param {UserId} signer
    * @param {DeviceKeyId} key_id
    * @param {Ed25519Signature} signature
    * @returns {MaybeSignature | undefined}
    */
    addSignature(signer, key_id, signature) {
        _assertClass(signer, UserId);
        _assertClass(key_id, DeviceKeyId);
        _assertClass(signature, Ed25519Signature);
        const ret = wasm.signatures_addSignature(this.ptr, signer.ptr, key_id.ptr, signature.ptr);
        return ret === 0 ? undefined : MaybeSignature.__wrap(ret);
    }
    /**
    * Try to find an Ed25519 signature from the given signer with
    * the given key ID.
    * @param {UserId} signer
    * @param {DeviceKeyId} key_id
    * @returns {Ed25519Signature | undefined}
    */
    getSignature(signer, key_id) {
        _assertClass(signer, UserId);
        _assertClass(key_id, DeviceKeyId);
        const ret = wasm.signatures_getSignature(this.ptr, signer.ptr, key_id.ptr);
        return ret === 0 ? undefined : Ed25519Signature.__wrap(ret);
    }
    /**
    * Get the map of signatures that belong to the given user.
    * @param {UserId} signer
    * @returns {Map<any, any> | undefined}
    */
    get(signer) {
        _assertClass(signer, UserId);
        const ret = wasm.signatures_get(this.ptr, signer.ptr);
        return takeObject(ret);
    }
    /**
    * Remove all the signatures we currently hold.
    */
    clear() {
        wasm.signatures_clear(this.ptr);
    }
    /**
    * Do we hold any signatures or is our collection completely
    * empty.
    * @returns {boolean}
    */
    isEmpty() {
        const ret = wasm.signatures_isEmpty(this.ptr);
        return ret !== 0;
    }
    /**
    * How many signatures do we currently hold.
    * @returns {number}
    */
    get count() {
        const ret = wasm.signatures_count(this.ptr);
        return ret >>> 0;
    }
}
module.exports.Signatures = Signatures;

const SigningKeysUploadRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_signingkeysuploadrequest_free(ptr));
/**
* Other Requests *
* Request that will publish a cross signing identity.
*
* This uploads the public cross signing key triplet.
*/
class SigningKeysUploadRequest {

    static __wrap(ptr) {
        const obj = Object.create(SigningKeysUploadRequest.prototype);
        obj.ptr = ptr;
        SigningKeysUploadRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        SigningKeysUploadRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_signingkeysuploadrequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `master_key`,
    * `self_signing_key`, `user_signing_key`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
}
module.exports.SigningKeysUploadRequest = SigningKeysUploadRequest;

const ToDeviceRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_todevicerequest_free(ptr));
/**
* Data for a request to the `/sendToDevice` API endpoint
* ([specification]).
*
* Send an event to a single device or to a group of devices.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3sendtodeviceeventtypetxnid
*/
class ToDeviceRequest {

    static __wrap(ptr) {
        const obj = Object.create(ToDeviceRequest.prototype);
        obj.ptr = ptr;
        ToDeviceRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        ToDeviceRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_todevicerequest_free(ptr);
    }
    /**
    * The request ID.
    * @returns {string | undefined}
    */
    get id() {
        const ret = wasm.__wbg_get_keysbackuprequest_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A string representing the type of event being sent to each devices.
    * @returns {string}
    */
    get event_type() {
        const ret = wasm.__wbg_get_keysbackuprequest_body(this.ptr);
        return takeObject(ret);
    }
    /**
    * A string representing a request identifier unique to the access token
    * used to send the request.
    * @returns {string}
    */
    get txn_id() {
        const ret = wasm.__wbg_get_roommessagerequest_txn_id(this.ptr);
        return takeObject(ret);
    }
    /**
    * A JSON-encoded string containing the rest of the payload: `messages`.
    *
    * It represents the body of the HTTP request.
    * @returns {string}
    */
    get body() {
        const ret = wasm.__wbg_get_roommessagerequest_event_type(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a new `ToDeviceRequest`.
    * @param {string} id
    * @param {string} event_type
    * @param {string} txn_id
    * @param {string} body
    */
    constructor(id, event_type, txn_id, body) {
        const ret = wasm.todevicerequest_new(addHeapObject(id), addHeapObject(event_type), addHeapObject(txn_id), addHeapObject(body));
        return ToDeviceRequest.__wrap(ret);
    }
    /**
    * Get its request type.
    * @returns {number}
    */
    get type() {
        const ret = wasm.todevicerequest_type(this.ptr);
        return ret >>> 0;
    }
}
module.exports.ToDeviceRequest = ToDeviceRequest;

const TracingFinalization = new FinalizationRegistry(ptr => wasm.__wbg_tracing_free(ptr));
/**
* Type to install and to manipulate the tracing layer.
*/
class Tracing {

    static __wrap(ptr) {
        const obj = Object.create(Tracing.prototype);
        obj.ptr = ptr;
        TracingFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        TracingFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_tracing_free(ptr);
    }
    /**
    * Check whether the `tracing` feature has been enabled.
    * @returns {boolean}
    */
    static isAvailable() {
        const ret = wasm.tracing_isAvailable();
        return ret !== 0;
    }
    /**
    * Install the tracing layer.
    *
    * `Tracing` is a singleton. Once it is installed,
    * consecutive calls to the constructor will construct a new
    * `Tracing` object but with the exact same inner
    * state. Calling the constructor with a new `min_level` will
    * just update the `min_level` parameter; in that regard, it
    * is similar to calling the `min_level` method on an
    * existing `Tracing` object.
    * @param {number} min_level
    */
    constructor(min_level) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.tracing_new(retptr, min_level);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return Tracing.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Re-define the minimum logger level.
    * @param {number} min_level
    */
    set minLevel(min_level) {
        wasm.tracing_set_minLevel(this.ptr, min_level);
    }
    /**
    * Turn the logger on, i.e. it emits logs again if it was turned
    * off.
    */
    turnOn() {
        wasm.tracing_turnOn(this.ptr);
    }
    /**
    * Turn the logger off, i.e. it no long emits logs.
    */
    turnOff() {
        wasm.tracing_turnOff(this.ptr);
    }
}
module.exports.Tracing = Tracing;

const UserDevicesFinalization = new FinalizationRegistry(ptr => wasm.__wbg_userdevices_free(ptr));
/**
* A read only view over all devices belonging to a user.
*/
class UserDevices {

    static __wrap(ptr) {
        const obj = Object.create(UserDevices.prototype);
        obj.ptr = ptr;
        UserDevicesFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UserDevicesFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_userdevices_free(ptr);
    }
    /**
    * Get the specific device with the given device ID.
    * @param {DeviceId} device_id
    * @returns {Device | undefined}
    */
    get(device_id) {
        _assertClass(device_id, DeviceId);
        const ret = wasm.userdevices_get(this.ptr, device_id.ptr);
        return ret === 0 ? undefined : Device.__wrap(ret);
    }
    /**
    * Returns true if there is at least one devices of this user
    * that is considered to be verified, false otherwise.
    *
    * This won't consider your own device as verified, as your own
    * device is always implicitly verified.
    * @returns {boolean}
    */
    isAnyVerified() {
        const ret = wasm.userdevices_isAnyVerified(this.ptr);
        return ret !== 0;
    }
    /**
    * Array over all the device IDs of the user devices.
    * @returns {Array<any>}
    */
    keys() {
        const ret = wasm.userdevices_keys(this.ptr);
        return takeObject(ret);
    }
    /**
    * Iterator over all the devices of the user devices.
    * @returns {Array<any>}
    */
    devices() {
        const ret = wasm.userdevices_devices(this.ptr);
        return takeObject(ret);
    }
}
module.exports.UserDevices = UserDevices;

const UserIdFinalization = new FinalizationRegistry(ptr => wasm.__wbg_userid_free(ptr));
/**
* A Matrix [user ID].
*
* [user ID]: https://spec.matrix.org/v1.2/appendices/#user-identifiers
*/
class UserId {

    static __wrap(ptr) {
        const obj = Object.create(UserId.prototype);
        obj.ptr = ptr;
        UserIdFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UserIdFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_userid_free(ptr);
    }
    /**
    * Parse/validate and create a new `UserId`.
    * @param {string} id
    */
    constructor(id) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            const ptr0 = passStringToWasm0(id, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
            const len0 = WASM_VECTOR_LEN;
            wasm.userid_new(retptr, ptr0, len0);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return UserId.__wrap(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Returns the user's localpart.
    * @returns {string}
    */
    get localpart() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.userid_localpart(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Returns the server name of the user ID.
    * @returns {ServerName}
    */
    get serverName() {
        const ret = wasm.userid_serverName(this.ptr);
        return ServerName.__wrap(ret);
    }
    /**
    * Whether this user ID is a historical one.
    *
    * A historical user ID is one that doesn't conform to the latest
    * specification of the user ID grammar but is still accepted
    * because it was previously allowed.
    * @returns {boolean}
    */
    isHistorical() {
        const ret = wasm.userid_isHistorical(this.ptr);
        return ret !== 0;
    }
    /**
    * Return the user ID as a string.
    * @returns {string}
    */
    toString() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.deviceid_toString(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
}
module.exports.UserId = UserId;

const UserIdentityFinalization = new FinalizationRegistry(ptr => wasm.__wbg_useridentity_free(ptr));
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that isn't our own. Other users will
* only contain a master key and a self signing key, meaning that only device
* signatures can be checked with this identity.
*
* This struct wraps a read-only version of the struct and allows verifications
* to be requested to verify our own device with the user identity.
*/
class UserIdentity {

    static __wrap(ptr) {
        const obj = Object.create(UserIdentity.prototype);
        obj.ptr = ptr;
        UserIdentityFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        UserIdentityFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_useridentity_free(ptr);
    }
    /**
    * Is this user identity verified?
    * @returns {boolean}
    */
    isVerified() {
        const ret = wasm.useridentity_isVerified(this.ptr);
        return ret !== 0;
    }
    /**
    * Manually verify this user.
    *
    * This method will attempt to sign the user identity using our private
    * cross signing key.
    *
    * This method fails if we don't have the private part of our user-signing
    * key.
    *
    * Returns a request that needs to be sent out for the user to be marked as
    * verified.
    * @returns {Promise<any>}
    */
    verify() {
        const ret = wasm.useridentity_verify(this.ptr);
        return takeObject(ret);
    }
    /**
    * Create a `VerificationRequest` object after the verification
    * request content has been sent out.
    * @param {RoomId} room_id
    * @param {EventId} request_event_id
    * @param {Array<any> | undefined} methods
    * @returns {Promise<any>}
    */
    requestVerification(room_id, request_event_id, methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(room_id, RoomId);
            _assertClass(request_event_id, EventId);
            wasm.useridentity_requestVerification(retptr, this.ptr, room_id.ptr, request_event_id.ptr, isLikeNone(methods) ? 0 : addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Send a verification request to the given user.
    *
    * The returned content needs to be sent out into a DM room with the given
    * user.
    *
    * After the content has been sent out a VerificationRequest can be started
    * with the `request_verification` method.
    * @param {Array<any> | undefined} methods
    * @returns {Promise<any>}
    */
    verificationRequestContent(methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.useridentity_verificationRequestContent(retptr, this.ptr, isLikeNone(methods) ? 0 : addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
module.exports.UserIdentity = UserIdentity;

const VerificationRequestFinalization = new FinalizationRegistry(ptr => wasm.__wbg_verificationrequest_free(ptr));
/**
* An object controlling key verification requests.
*
* Interactive verification flows usually start with a verification
* request, this object lets you send and reply to such a
* verification request.
*
* After the initial handshake the verification flow transitions into
* one of the verification methods.
*/
class VerificationRequest {

    static __wrap(ptr) {
        const obj = Object.create(VerificationRequest.prototype);
        obj.ptr = ptr;
        VerificationRequestFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VerificationRequestFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_verificationrequest_free(ptr);
    }
    /**
    * Create an event content that can be sent as a room event to
    * request verification from the other side. This should be used
    * only for verifications of other users and it should be sent to
    * a room we consider to be a DM with the other user.
    * @param {UserId} own_user_id
    * @param {DeviceId} own_device_id
    * @param {UserId} other_user_id
    * @param {Array<any> | undefined} methods
    * @returns {string}
    */
    static request(own_user_id, own_device_id, other_user_id, methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            _assertClass(own_user_id, UserId);
            _assertClass(own_device_id, DeviceId);
            _assertClass(other_user_id, UserId);
            wasm.verificationrequest_request(retptr, own_user_id.ptr, own_device_id.ptr, other_user_id.ptr, isLikeNone(methods) ? 0 : addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            var r3 = getInt32Memory0()[retptr / 4 + 3];
            var ptr0 = r0;
            var len0 = r1;
            if (r3) {
                ptr0 = 0; len0 = 0;
                throw takeObject(r2);
            }
            return getStringFromWasm0(ptr0, len0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(ptr0, len0);
        }
    }
    /**
    * Our own user id.
    * @returns {UserId}
    */
    get ownUserId() {
        const ret = wasm.sas_userId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * The ID of the other user that is participating in this
    * verification request.
    * @returns {UserId}
    */
    get otherUserId() {
        const ret = wasm.verificationrequest_otherUserId(this.ptr);
        return UserId.__wrap(ret);
    }
    /**
    * The ID of the other device that is participating in this
    * verification.
    * @returns {DeviceId | undefined}
    */
    get otherDeviceId() {
        const ret = wasm.verificationrequest_otherDeviceId(this.ptr);
        return ret === 0 ? undefined : DeviceId.__wrap(ret);
    }
    /**
    * Get the room ID if the verification is happening inside a
    * room.
    * @returns {RoomId | undefined}
    */
    get roomId() {
        const ret = wasm.verificationrequest_roomId(this.ptr);
        return ret === 0 ? undefined : RoomId.__wrap(ret);
    }
    /**
    * Get info about the cancellation if the verification request
    * has been cancelled.
    * @returns {CancelInfo | undefined}
    */
    get cancelInfo() {
        const ret = wasm.verificationrequest_cancelInfo(this.ptr);
        return ret === 0 ? undefined : CancelInfo.__wrap(ret);
    }
    /**
    * Has the verification request been answered by another device.
    * @returns {boolean}
    */
    isPassive() {
        const ret = wasm.verificationrequest_isPassive(this.ptr);
        return ret !== 0;
    }
    /**
    * Is the verification request ready to start a verification flow.
    * @returns {boolean}
    */
    isReady() {
        const ret = wasm.verificationrequest_isReady(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the verification flow timed out.
    * @returns {boolean}
    */
    timedOut() {
        const ret = wasm.verificationrequest_timedOut(this.ptr);
        return ret !== 0;
    }
    /**
    * Get the supported verification methods of the other side.
    *
    * Will be present only if the other side requested the
    * verification or if we’re in the ready state.
    *
    * It return a `Option<Vec<VerificationMethod>>`.
    * @returns {Array<any> | undefined}
    */
    get theirSupportedMethods() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_theirSupportedMethods(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get our own supported verification methods that we advertised.
    *
    * Will be present only we requested the verification or if we’re
    * in the ready state.
    * @returns {Array<any> | undefined}
    */
    get ourSupportedMethods() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_ourSupportedMethods(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Get the unique ID of this verification request
    * @returns {string}
    */
    get flowId() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_flowId(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * Is this a verification that is veryfying one of our own
    * devices.
    * @returns {boolean}
    */
    isSelfVerification() {
        const ret = wasm.verificationrequest_isSelfVerification(this.ptr);
        return ret !== 0;
    }
    /**
    * Did we initiate the verification request.
    * @returns {boolean}
    */
    weStarted() {
        const ret = wasm.inboundgroupsession_hasBeenImported(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the verification flow that was started with this request
    * finished.
    * @returns {boolean}
    */
    isDone() {
        const ret = wasm.verificationrequest_isDone(this.ptr);
        return ret !== 0;
    }
    /**
    * Has the verification flow that was started with this request
    * been cancelled.
    * @returns {boolean}
    */
    isCancelled() {
        const ret = wasm.verificationrequest_isCancelled(this.ptr);
        return ret !== 0;
    }
    /**
    * Accept the verification request signaling that our client
    * supports the given verification methods.
    *
    * `methods` represents the methods that we should advertise as
    * supported by us.
    *
    * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
    * or `undefined`.
    * @param {Array<any>} methods
    * @returns {any}
    */
    acceptWithMethods(methods) {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_acceptWithMethods(retptr, this.ptr, addHeapObject(methods));
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Accept the verification request.
    *
    * This method will accept the request and signal that it
    * supports the `m.sas.v1`, the `m.qr_code.show.v1`, and
    * `m.reciprocate.v1` method.
    *
    * `m.qr_code.show.v1` will only be signaled if the `qrcode`
    * feature is enabled. This feature is disabled by default. If
    * it's enabled and QR code scanning should be supported or QR
    * code showing shouldn't be supported the `accept_with_methods`
    * method should be used instead.
    *
    * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
    * or `undefined`.
    * @returns {any}
    */
    accept() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_accept(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Cancel the verification request.
    *
    * It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
    * or `undefined`.
    * @returns {any}
    */
    cancel() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.verificationrequest_cancel(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var r2 = getInt32Memory0()[retptr / 4 + 2];
            if (r2) {
                throw takeObject(r1);
            }
            return takeObject(r0);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * Transition from this verification request into a SAS verification flow.
    * @returns {Promise<any>}
    */
    startSas() {
        const ret = wasm.verificationrequest_startSas(this.ptr);
        return takeObject(ret);
    }
    /**
    * Generate a QR code that can be used by another client to start
    * a QR code based verification.
    * @returns {Promise<any>}
    */
    generateQrCode() {
        const ret = wasm.verificationrequest_generateQrCode(this.ptr);
        return takeObject(ret);
    }
    /**
    * Start a QR code verification by providing a scanned QR code
    * for this verification flow.
    * @param {QrCodeScan} data
    * @returns {Promise<any>}
    */
    scanQrCode(data) {
        _assertClass(data, QrCodeScan);
        const ret = wasm.verificationrequest_scanQrCode(this.ptr, data.ptr);
        return takeObject(ret);
    }
}
module.exports.VerificationRequest = VerificationRequest;

const VersionsFinalization = new FinalizationRegistry(ptr => wasm.__wbg_versions_free(ptr));
/**
* Object containing the versions of the Rust libraries we are using.
*/
class Versions {

    static __wrap(ptr) {
        const obj = Object.create(Versions.prototype);
        obj.ptr = ptr;
        VersionsFinalization.register(obj, obj.ptr, obj);
        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;
        VersionsFinalization.unregister(this);
        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_versions_free(ptr);
    }
    /**
    * The version of the vodozemac crate.
    * @returns {string}
    */
    get vodozemac() {
        const ret = wasm.__wbg_get_versions_vodozemac(this.ptr);
        return takeObject(ret);
    }
    /**
    * The version of the matrix-sdk-crypto crate.
    * @returns {string}
    */
    get matrix_sdk_crypto() {
        const ret = wasm.__wbg_get_versions_matrix_sdk_crypto(this.ptr);
        return takeObject(ret);
    }
}
module.exports.Versions = Versions;

module.exports.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
};

module.exports.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr0 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_now_931686b195a14f9d = function() {
    const ret = Date.now();
    return ret;
};

module.exports.__wbg_setonblocked_78e53418c43a7090 = function(arg0, arg1) {
    getObject(arg0).onblocked = getObject(arg1);
};

module.exports.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
};

module.exports.__wbg_new_b525de17f44a8943 = function() {
    const ret = new Array();
    return addHeapObject(ret);
};

module.exports.__wbg_signingkeysuploadrequest_new = function(arg0) {
    const ret = SigningKeysUploadRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_set_17224bc548dd1d7b = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
};

module.exports.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_userdevices_new = function(arg0) {
    const ret = UserDevices.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_crosssigningkeyexport_new = function(arg0) {
    const ret = CrossSigningKeyExport.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_add_71fc27cfcbd2eda6 = function(arg0, arg1) {
    const ret = getObject(arg0).add(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_signatures_new = function(arg0) {
    const ret = Signatures.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_inboundgroupsession_new = function(arg0) {
    const ret = InboundGroupSession.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;
    return ret;
};

module.exports.__wbg_olmmachine_new = function(arg0) {
    const ret = OlmMachine.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_decryptedroomevent_new = function(arg0) {
    const ret = DecryptedRoomEvent.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_push_49c286f04dd3bf59 = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
};

module.exports.__wbg_ownuseridentity_new = function(arg0) {
    const ret = OwnUserIdentity.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_useridentity_new = function(arg0) {
    const ret = UserIdentity.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_call_96878afb7a8201ca = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_b28bac5b9193a9b1 = function(arg0) {
    const ret = new Set(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_length_e498fbc24f9c1d4f = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_entries_003a3a46f730c8a8 = function(arg0) {
    const ret = getObject(arg0).entries();
    return addHeapObject(ret);
};

module.exports.__wbg_values_fd18605dd7ddb3cc = function(arg0) {
    const ret = getObject(arg0).values();
    return addHeapObject(ret);
};

module.exports.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
};

module.exports.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbg_randomFillSync_6894564c2c334c42 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_getRandomValues_805f1c3d65988a5a = function() { return handleError(function (arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
}, arguments) };

module.exports.__wbg_crypto_e1d53a1d73fb10b8 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbg_process_038c26bf42b093f8 = function(arg0) {
    const ret = getObject(arg0).process;
    return addHeapObject(ret);
};

module.exports.__wbg_versions_ab37218d2f0b24a8 = function(arg0) {
    const ret = getObject(arg0).versions;
    return addHeapObject(ret);
};

module.exports.__wbg_node_080f4b19d15bc1fe = function(arg0) {
    const ret = getObject(arg0).node;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_string = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'string';
    return ret;
};

module.exports.__wbg_require_78a3dcfbdba9cbce = function() { return handleError(function () {
    const ret = module.require;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbindgen_is_function = function(arg0) {
    const ret = typeof(getObject(arg0)) === 'function';
    return ret;
};

module.exports.__wbg_msCrypto_6e7d3e1f92610cbb = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

module.exports.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
};

module.exports.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === undefined;
    return ret;
};

module.exports.__wbg_static_accessor_MODULE_ef3aa2eb251158a5 = function() {
    const ret = module;
    return addHeapObject(ret);
};

module.exports.__wbg_clearTimeout_76877dbc010e786d = function(arg0) {
    const ret = clearTimeout(takeObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
        obj.a = 0;
        return true;
    }
    const ret = false;
    return ret;
};

module.exports.__wbg_setTimeout_75cb9b6991a4031d = function() { return handleError(function (arg0, arg1) {
    const ret = setTimeout(getObject(arg0), arg1);
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_Window_2323448e22bf340f = function(arg0) {
    const ret = getObject(arg0).Window;
    return addHeapObject(ret);
};

module.exports.__wbg_WorkerGlobalScope_4f52a4f4757baa51 = function(arg0) {
    const ret = getObject(arg0).WorkerGlobalScope;
    return addHeapObject(ret);
};

module.exports.__wbg_global_bb13ba737d1fd37d = function(arg0) {
    const ret = getObject(arg0).global;
    return addHeapObject(ret);
};

module.exports.__wbg_indexedDB_553c6eee256a5956 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_indexedDB_47544d523ac2a208 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_indexedDB_83385e4ce65e9054 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).indexedDB;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_open_2f9bdc2df25fc92e = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).open(getStringFromWasm0(arg1, arg2), arg3 >>> 0);
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_setonversionchange_fd71954420371ad8 = function(arg0, arg1) {
    getObject(arg0).onversionchange = getObject(arg1);
};

module.exports.__wbg_transaction_6d097d62f550220d = function() { return handleError(function (arg0, arg1, arg2, arg3) {
    const ret = getObject(arg0).transaction(getStringFromWasm0(arg1, arg2), takeObject(arg3));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_createObjectStore_ebb17df1a43fd925 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).createObjectStore(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_newwithmessage_ff6e8502f3396299 = function() { return handleError(function (arg0, arg1) {
    const ret = new DOMException(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_readyState_d9cf5eb3487e31d6 = function(arg0) {
    const ret = getObject(arg0).readyState;
    return addHeapObject(ret);
};

module.exports.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_objectStore_cdc69f65ad4a71eb = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).objectStore(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_get_27fe3dac1c4d0224 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
};

module.exports.__wbg_next_88560ec06a094dea = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).next();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_done_1ebec03bbd919843 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
};

module.exports.__wbg_value_6ac8da5cc5b3efda = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
};

module.exports.__wbg_self_e7c1f827057f6584 = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_window_a09ec664e14b1b81 = function() { return handleError(function () {
    const ret = window.window;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_globalThis_87cbb8506fecf3a9 = function() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_global_c85a9259e621f3db = function() { return handleError(function () {
    const ret = global.global;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_newnoargs_2b8b6bd7753c76ba = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_call_95d1ea488d03e4e8 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).call(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_call_9495de66fdbe016b = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_new_9d3a9ce4282a18a8 = function(arg0, arg1) {
    try {
        var state0 = {a: arg0, b: arg1};
        var cb0 = (arg0, arg1) => {
            const a = state0.a;
            state0.a = 0;
            try {
                return __wbg_adapter_186(a, state0.b, arg0, arg1);
            } finally {
                state0.a = a;
            }
        };
        const ret = new Promise(cb0);
        return addHeapObject(ret);
    } finally {
        state0.a = state0.b = 0;
    }
};

module.exports.__wbg_length_27a2afe8ab42b09f = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
};

module.exports.__wbg_buffer_cf65c07de34b9a08 = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
};

module.exports.__wbg_new_537b7341ce90bb31 = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_set_17499e8aa4003ebd = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_set_d1017675d13cf3d5 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
};

module.exports.__wbg_length_065287541268ea52 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
};

module.exports.__wbg_newwithbyteoffsetandlength_a04f81daba99fdcb = function(arg0, arg1, arg2) {
    const ret = new Uint8ClampedArray(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_newwithlength_b56c882b57805732 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_subarray_7526649b91a252a6 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_parse_3ac95b51fc312db8 = function() { return handleError(function (arg0, arg1) {
    const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_stringify_029a979dfb73aa17 = function() { return handleError(function (arg0) {
    const ret = JSON.stringify(getObject(arg0));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_roommessagerequest_new = function(arg0) {
    const ret = RoomMessageRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_signatureuploadrequest_new = function(arg0) {
    const ret = SignatureUploadRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_todevicerequest_new = function(arg0) {
    const ret = ToDeviceRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysclaimrequest_new = function(arg0) {
    const ret = KeysClaimRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_debug_c404cd597e83ccc2 = function(arg0, arg1) {
    try {
        console.debug(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbg_sas_new = function(arg0) {
    const ret = Sas.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_qr_new = function(arg0) {
    const ret = Qr.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_device_new = function(arg0) {
    const ret = Device.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_userid_new = function(arg0) {
    const ret = UserId.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_verificationrequest_new = function(arg0) {
    const ret = VerificationRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_oldVersion_a244bb7dfbac7adc = function(arg0) {
    const ret = getObject(arg0).oldVersion;
    return ret;
};

module.exports.__wbg_deleteObjectStore_a67245ba486fb641 = function() { return handleError(function (arg0, arg1, arg2) {
    getObject(arg0).deleteObjectStore(getStringFromWasm0(arg1, arg2));
}, arguments) };

module.exports.__wbg_crosssigningstatus_new = function(arg0) {
    const ret = CrossSigningStatus.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof(obj) === 'number' ? obj : undefined;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
};

module.exports.__wbindgen_typeof = function(arg0) {
    const ret = typeof getObject(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysuploadrequest_new = function(arg0) {
    const ret = KeysUploadRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysqueryrequest_new = function(arg0) {
    const ret = KeysQueryRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_keysbackuprequest_new = function(arg0) {
    const ret = KeysBackupRequest.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_info_c63248f6d6536f02 = function(arg0, arg1) {
    try {
        console.info(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbg_warn_44043b1ec39371f9 = function(arg0, arg1) {
    try {
        console.warn(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbg_error_986b28416065cc9d = function(arg0, arg1) {
    try {
        console.error(getStringFromWasm0(arg0, arg1));
    } finally {
        wasm.__wbindgen_free(arg0, arg1);
    }
};

module.exports.__wbg_new_f841cc6f2098f4b5 = function() {
    const ret = new Map();
    return addHeapObject(ret);
};

module.exports.__wbg_devicekeyid_new = function(arg0) {
    const ret = DeviceKeyId.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_devicekey_new = function(arg0) {
    const ret = DeviceKey.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_set_388c4c6422704173 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_deviceid_new = function(arg0) {
    const ret = DeviceId.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_getPrototypeOf_bc92b90803c143ac = function(arg0) {
    const ret = Object.getPrototypeOf(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_constructor_0c9828c8a7cf1dc6 = function(arg0) {
    const ret = getObject(arg0).constructor;
    return addHeapObject(ret);
};

module.exports.__wbg_name_4e66d4cfa3e9270a = function(arg0) {
    const ret = getObject(arg0).name;
    return addHeapObject(ret);
};

module.exports.__wbg_get_baf4855f9a986186 = function() { return handleError(function (arg0, arg1) {
    const ret = Reflect.get(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
};

module.exports.__wbg_emoji_new = function(arg0) {
    const ret = Emoji.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_newwithlength_0da6f12fbc1ab6eb = function(arg0) {
    const ret = new Array(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_newwithlength_bbd91f6c803e282b = function(arg0) {
    const ret = new Uint8ClampedArray(arg0 >>> 0);
    return addHeapObject(ret);
};

module.exports.__wbg_new_03e65ab6ee0581bb = function(arg0) {
    const ret = new Uint8ClampedArray(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_maybesignature_new = function(arg0) {
    const ret = MaybeSignature.__wrap(arg0);
    return addHeapObject(ret);
};

module.exports.__wbg_from_67ca20fa722467e6 = function(arg0) {
    const ret = Array.from(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_at_155d8a5ce48004cd = function(arg0, arg1) {
    const ret = getObject(arg0).at(arg1);
    return addHeapObject(ret);
};

module.exports.__wbg_put_fdcda25ee2a99b60 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).put(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_delete_d2905418845867ae = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).delete(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_name_179b35bcd8e98790 = function(arg0, arg1) {
    const ret = getObject(arg1).name;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_message_f15effc8b20828e2 = function(arg0, arg1) {
    const ret = getObject(arg1).message;
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbg_code_246c67ea4a444045 = function(arg0) {
    const ret = getObject(arg0).code;
    return ret;
};

module.exports.__wbg_transaction_a31cc90bd4f34364 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject(arg0).transaction(getObject(arg1), takeObject(arg2));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_getAllKeys_02e4a305dbe6a90a = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).getAllKeys();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_getAll_452d1b5d83fca36a = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).getAll(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_getAll_8f9129621bfdd7cc = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).getAll();
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_self_7eede1f4488bf346 = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_crypto_c909fb428dcbddb6 = function(arg0) {
    const ret = getObject(arg0).crypto;
    return addHeapObject(ret);
};

module.exports.__wbg_msCrypto_511eefefbfc70ae4 = function(arg0) {
    const ret = getObject(arg0).msCrypto;
    return addHeapObject(ret);
};

module.exports.__wbg_require_900d5c3984fe7703 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).require(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
};

module.exports.__wbg_getRandomValues_307049345d0bd88c = function(arg0) {
    const ret = getObject(arg0).getRandomValues;
    return addHeapObject(ret);
};

module.exports.__wbg_randomFillSync_85b3f4c52c56c313 = function(arg0, arg1, arg2) {
    getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
};

module.exports.__wbg_getRandomValues_cd175915511f705e = function(arg0, arg1) {
    getObject(arg0).getRandomValues(getObject(arg1));
};

module.exports.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len0;
    getInt32Memory0()[arg0 / 4 + 0] = ptr0;
};

module.exports.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
};

module.exports.__wbg_resolve_fd40f858d9db1a04 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
};

module.exports.__wbg_then_ec5db6d509eb475f = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
};

module.exports.__wbg_setonabort_0e116e0f6f9fc3a6 = function(arg0, arg1) {
    getObject(arg0).onabort = getObject(arg1);
};

module.exports.__wbg_setoncomplete_f32167d3f84be687 = function(arg0, arg1) {
    getObject(arg0).oncomplete = getObject(arg1);
};

module.exports.__wbg_setonerror_7cbe775a0abc7a8e = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
};

module.exports.__wbg_close_98f3a5ab91060b8b = function(arg0) {
    getObject(arg0).close();
};

module.exports.__wbg_setonupgradeneeded_8961be061344d04a = function(arg0, arg1) {
    getObject(arg0).onupgradeneeded = getObject(arg1);
};

module.exports.__wbg_get_18b8195859195e7e = function() { return handleError(function (arg0, arg1) {
    const ret = getObject(arg0).get(getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_result_3a1fef332bc47038 = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).result;
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbg_error_f64b8d41ed4d2fdc = function() { return handleError(function (arg0) {
    const ret = getObject(arg0).error;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
}, arguments) };

module.exports.__wbg_setonsuccess_925a7718d3f62bc1 = function(arg0, arg1) {
    getObject(arg0).onsuccess = getObject(arg1);
};

module.exports.__wbg_setonerror_019196fbce756cc0 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
};

module.exports.__wbg_target_b629c177f9bee3da = function(arg0) {
    const ret = getObject(arg0).target;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
};

module.exports.__wbg_bound_6ec97c4ac941863b = function() { return handleError(function (arg0, arg1) {
    const ret = IDBKeyRange.bound(getObject(arg0), getObject(arg1));
    return addHeapObject(ret);
}, arguments) };

module.exports.__wbindgen_closure_wrapper1380 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 88, __wbg_adapter_38);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper2878 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 83, __wbg_adapter_41);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper2917 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 88, __wbg_adapter_44);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper2930 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 88, __wbg_adapter_47);
    return addHeapObject(ret);
};

module.exports.__wbindgen_closure_wrapper8633 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 83, __wbg_adapter_50);
    return addHeapObject(ret);
};

// Initially, 'wasm' is set to a Proxy object which will synchronously load the WebAssembly module and
// replace 'wasm' with a reference to the exports from the wasm module.
//
// Ideally this will never get used because the application will call initAsync instead.
wasm = new Proxy(
    {},
    {
        get: (target, prop, receiver) => __initSync()[prop],
    },
);

let inited = false;
__initSync = function () {
    if (inited) {
        return;
    }
    if (initPromise) {
        throw new Error("Asynchronous initialisation already in progress: cannot initialise synchronously");
    }
    const bytes = unbase64(require("./matrix_sdk_crypto_js_bg.wasm.js"));
    const mod = new WebAssembly.Module(bytes);
    const instance = new WebAssembly.Instance(mod, imports);
    wasm = instance.exports;
    wasm.__wbindgen_start();
    inited = true;
    return wasm;
};

let initPromise = null;

/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
module.exports.initAsync = function () {
    if (inited) {
        return Promise.resolve();
    }
    if (!initPromise) {
        initPromise = Promise.resolve()
            .then(() => require("./matrix_sdk_crypto_js_bg.wasm.js"))
            .then((b64) => WebAssembly.instantiate(unbase64(b64), imports))
            .then((result) => {
                wasm = result.instance.exports;
                wasm.__wbindgen_start();
                inited = true;
            });
    }
    return initPromise;
};

const b64lookup = new Uint8Array([
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 62, 0, 62, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7,
    8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 63, 0, 26, 27, 28, 29, 30, 31, 32,
    33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
]);

// base64 decoder, based on the code at https://developer.mozilla.org/en-US/docs/Glossary/Base64#solution_2_%E2%80%93_rewriting_atob_and_btoa_using_typedarrays_and_utf-8
function unbase64(sBase64) {
    const sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, "");
    const nInLen = sB64Enc.length;
    const nOutLen = (nInLen * 3 + 1) >> 2;
    const taBytes = new Uint8Array(nOutLen);

    let nMod3;
    let nMod4;
    let nUint24 = 0;
    let nOutIdx = 0;
    for (let nInIdx = 0; nInIdx < nInLen; nInIdx++) {
        nMod4 = nInIdx & 3;
        nUint24 |= b64lookup[sB64Enc.charCodeAt(nInIdx)] << (6 * (3 - nMod4));
        if (nMod4 === 3 || nInLen - nInIdx === 1) {
            nMod3 = 0;
            while (nMod3 < 3 && nOutIdx < nOutLen) {
                taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;
                nMod3++;
                nOutIdx++;
            }
            nUint24 = 0;
        }
    }

    return taBytes;
}
