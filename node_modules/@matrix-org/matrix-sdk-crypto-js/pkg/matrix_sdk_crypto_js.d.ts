/* tslint:disable */
/* eslint-disable */
/**
* Get the versions of the Rust libraries we are using.
* @returns {Versions}
*/
export function getVersions(): Versions;
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
export function start(): void;
/**
* Who can see a room's history.
*/
export enum HistoryVisibility {
/**
* Previous events are accessible to newly joined members from
* the point they were invited onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *invite* or *join*.
*/
  Invited = 0,
/**
* Previous events are accessible to newly joined members from
* the point they joined the room onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *join*.
*/
  Joined = 1,
/**
* Previous events are always accessible to newly joined members.
*
* All events in the room are accessible, even those sent when
* the member was not a part of the room.
*/
  Shared = 2,
/**
* All events while this is the `HistoryVisibility` value may be
* shared by any participating homeserver with anyone, regardless
* of whether they have ever joined the room.
*/
  WorldReadable = 3,
}
/**
* The basic key algorithm names in the specification.
*/
export enum DeviceKeyAlgorithmName {
/**
* The Ed25519 signature algorithm.
*/
  Ed25519 = 0,
/**
* The Curve25519 ECDH algorithm.
*/
  Curve25519 = 1,
/**
* The Curve25519 ECDH algorithm, but the key also contains
* signatures.
*/
  SignedCurve25519 = 2,
/**
* An unknown device key algorithm.
*/
  Unknown = 3,
}
/**
* Represent the type of a request.
*/
export enum RequestType {
/**
* Represents a `KeysUploadRequest`.
*/
  KeysUpload = 0,
/**
* Represents a `KeysQueryRequest`.
*/
  KeysQuery = 1,
/**
* Represents a `KeysClaimRequest`.
*/
  KeysClaim = 2,
/**
* Represents a `ToDeviceRequest`.
*/
  ToDevice = 3,
/**
* Represents a `SignatureUploadRequest`.
*/
  SignatureUpload = 4,
/**
* Represents a `RoomMessageRequest`.
*/
  RoomMessage = 5,
/**
* Represents a `KeysBackupRequest`.
*/
  KeysBackup = 6,
}
/**
* An encryption algorithm to be used to encrypt messages sent to a
* room.
*/
export enum EncryptionAlgorithm {
/**
* Olm version 1 using Curve25519, AES-256, and SHA-256.
*/
  OlmV1Curve25519AesSha2 = 0,
/**
* Megolm version 1 using AES-256 and SHA-256.
*/
  MegolmV1AesSha2 = 1,
}
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
export enum ShieldColor {
/**
* Important warning
*/
  Red = 0,
/**
* Low warning
*/
  Grey = 1,
/**
* No warning
*/
  None = 2,
}
/**
* The local trust state of a device.
*/
export enum LocalTrust {
/**
* The device has been verified and is trusted.
*/
  Verified = 0,
/**
* The device been blacklisted from communicating.
*/
  BlackListed = 1,
/**
* The trust state of the device is being ignored.
*/
  Ignored = 2,
/**
* The trust state is unset.
*/
  Unset = 3,
}
/**
* Logger level.
*/
export enum LoggerLevel {
/**
* `TRACE` level.
*
* Designate very low priority, often extremely verbose,
* information.
*/
  Trace = 0,
/**
* `DEBUG` level.
*
* Designate lower priority information.
*/
  Debug = 1,
/**
* `INFO` level.
*
* Designate useful information.
*/
  Info = 2,
/**
* `WARN` level.
*
* Designate hazardous situations.
*/
  Warn = 3,
/**
* `ERROR` level.
*
* Designate very serious errors.
*/
  Error = 4,
}
/**
* List of available verification methods.
*/
export enum VerificationMethod {
/**
* The `m.sas.v1` verification method.
*
* SAS means Short Authentication String.
*/
  SasV1 = 0,
/**
* The `m.qr_code.scan.v1` verification method.
*/
  QrCodeScanV1 = 1,
/**
* The `m.qr_code.show.v1` verification method.
*/
  QrCodeShowV1 = 2,
/**
* The `m.reciprocate.v1` verification method.
*/
  ReciprocateV1 = 3,
}
/**
* An error code for why the process/request was cancelled by the
* user.
*/
export enum CancelCode {
/**
* Unknown cancel code.
*/
  Other = 0,
/**
* The user cancelled the verification.
*/
  User = 1,
/**
* The verification process timed out.
*
* Verification processes can define their own timeout
* parameters.
*/
  Timeout = 2,
/**
* The device does not know about the given transaction ID.
*/
  UnknownTransaction = 3,
/**
* The device does not know how to handle the requested method.
*
* Should be sent for `m.key.verification.start` messages and
* messages defined by individual verification processes.
*/
  UnknownMethod = 4,
/**
* The device received an unexpected message.
*
* Typically raised when one of the parties is handling the
* verification out of order.
*/
  UnexpectedMessage = 5,
/**
* The key was not verified.
*/
  KeyMismatch = 6,
/**
* The expected user did not match the user verified.
*/
  UserMismatch = 7,
/**
* The message received was invalid.
*/
  InvalidMessage = 8,
/**
* An `m.key.verification.request` was accepted by a different
* device.
*
* The device receiving this error can ignore the verification
* request.
*/
  Accepted = 9,
/**
* The device receiving this error can ignore the verification
* request.
*/
  MismatchedCommitment = 10,
/**
* The SAS did not match.
*/
  MismatchedSas = 11,
}
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
export enum DeviceKeyName {
/**
* The curve25519 device key.
*/
  Curve25519 = 0,
/**
* The ed25519 device key.
*/
  Ed25519 = 1,
/**
* An unknown device key.
*/
  Unknown = 2,
}
/**
* A type to encrypt and to decrypt anything that can fit in an
* `Uint8Array`, usually big buffer.
*/
export class Attachment {
  free(): void;
/**
* Encrypt the content of the `Uint8Array`.
*
* It produces an `EncryptedAttachment`, which can be used to
* retrieve the media encryption information, or the encrypted
* data.
* @param {Uint8Array} array
* @returns {EncryptedAttachment}
*/
  static encrypt(array: Uint8Array): EncryptedAttachment;
/**
* Decrypt an `EncryptedAttachment`.
*
* The encrypted attachment can be created manually, or from the
* `encrypt` method.
*
* **Warning**: The encrypted attachment can be used only
* **once**! The encrypted data will still be present, but the
* media encryption info (which contain secrets) will be
* destroyed. It is still possible to get a JSON-encoded backup
* by calling `EncryptedAttachment.mediaEncryptionInfo`.
* @param {EncryptedAttachment} attachment
* @returns {Uint8Array}
*/
  static decrypt(attachment: EncryptedAttachment): Uint8Array;
}
/**
* Information about the cancellation of a verification request or
* verification flow.
*/
export class CancelInfo {
  free(): void;
/**
* Get the human readable reason of the cancellation.
* @returns {string}
*/
  reason(): string;
/**
* Get the `CancelCode` that cancelled this verification.
* @returns {number}
*/
  cancelCode(): number;
/**
* Was the verification cancelled by us?
* @returns {boolean}
*/
  cancelledbyUs(): boolean;
}
/**
* A struct containing private cross signing keys that can be backed
* up or uploaded to the secret store.
*/
export class CrossSigningKeyExport {
  free(): void;
/**
* The seed of the master key encoded as unpadded base64.
*/
  readonly masterKey: string | undefined;
/**
* The seed of the self signing key encoded as unpadded base64.
*/
  readonly self_signing_key: string | undefined;
/**
* The seed of the user signing key encoded as unpadded base64.
*/
  readonly userSigningKey: string | undefined;
}
/**
* Struct representing the state of our private cross signing keys,
* it shows which private cross signing keys we have locally stored.
*/
export class CrossSigningStatus {
  free(): void;
/**
* Do we have the master key?
*/
  readonly hasMaster: boolean;
/**
* Do we have the self signing key? This one is necessary to sign
* our own devices.
*/
  readonly hasSelfSigning: boolean;
/**
* Do we have the user signing key? This one is necessary to sign
* other users.
*/
  readonly hasUserSigning: boolean;
}
/**
* A Curve25519 public key.
*/
export class Curve25519PublicKey {
  free(): void;
/**
* Serialize an Curve25519 public key to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
/**
* The number of bytes a Curve25519 public key has.
*/
  readonly length: number;
}
/**
* A decrypted room event.
*/
export class DecryptedRoomEvent {
  free(): void;
/**
* The verification state of the device that sent us the event,
* note this is the state of the device at the time of
* decryption. It may change in the future if a device gets
* verified or deleted.
* @param {boolean} strict
* @returns {ShieldState | undefined}
*/
  shieldState(strict: boolean): ShieldState | undefined;
/**
* The JSON-encoded decrypted event.
*/
  readonly event: string;
/**
* Chain of Curve25519 keys through which this session was
* forwarded, via `m.forwarded_room_key` events.
*/
  readonly forwardingCurve25519KeyChain: Array<any>;
/**
* The user ID of the event sender, note this is untrusted data
* unless the `verification_state` is as well trusted.
*/
  readonly sender: UserId | undefined;
/**
* The signing Ed25519 key that have created the megolm key that
* was used to decrypt this session.
*/
  readonly senderClaimedEd25519Key: string | undefined;
/**
* The Curve25519 key of the device that created the megolm
* decryption key originally.
*/
  readonly senderCurve25519Key: string | undefined;
/**
* The device ID of the device that sent us the event, note this
* is untrusted data unless `verification_state` is as well
* trusted.
*/
  readonly senderDevice: DeviceId | undefined;
}
/**
* A device represents a E2EE capable client of an user.
*/
export class Device {
  free(): void;
/**
* Request an interactive verification with this device.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(methods?: Array<any>): Promise<any>;
/**
* Is this device considered to be verified.
*
* This method returns true if either the `is_locally_trusted`
* method returns `true` or if the `is_cross_signing_trusted`
* method returns `true`.
* @returns {boolean}
*/
  isVerified(): boolean;
/**
* Is this device considered to be verified using cross signing.
* @returns {boolean}
*/
  isCrossSigningTrusted(): boolean;
/**
* Set the local trust state of the device to the given state.
*
* This won‚Äôt affect any cross signing trust state, this only
* sets a flag marking to have the given trust state.
*
* `trust_state` represents the new trust state that should be
* set for the device.
* @param {number} local_state
* @returns {Promise<any>}
*/
  setLocalTrust(local_state: number): Promise<any>;
/**
* Get the key of the given key algorithm belonging to this device.
* @param {number} algorithm
* @returns {DeviceKey | undefined}
*/
  getKey(algorithm: number): DeviceKey | undefined;
/**
* Is the device locally marked as trusted?
* @returns {boolean}
*/
  isLocallyTrusted(): boolean;
/**
* Is the device locally marked as blacklisted?
*
* Blacklisted devices won‚Äôt receive any group sessions.
* @returns {boolean}
*/
  isBlacklisted(): boolean;
/**
* Is the device deleted?
* @returns {boolean}
*/
  isDeleted(): boolean;
/**
* Get the Curve25519 key of the given device.
*/
  readonly curve25519Key: Curve25519PublicKey | undefined;
/**
* The unique ID of the device.
*/
  readonly deviceId: DeviceId;
/**
* Get the human readable name of the device.
*/
  readonly displayName: string | undefined;
/**
* Get the Ed25519 key of the given device.
*/
  readonly ed25519Key: Ed25519PublicKey | undefined;
/**
* Get a map containing all the device keys.
*/
  readonly keys: Map<any, any>;
/**
* Get the trust state of the device.
*/
  readonly localTrustState: number;
/**
* Get a map containing all the device signatures.
*/
  readonly signatures: Signatures;
/**
* The user ID of the device owner.
*/
  readonly userId: UserId;
}
/**
* A Matrix key ID.
*
* Device identifiers in Matrix are completely opaque character
* sequences. This type is provided simply for its semantic value.
*/
export class DeviceId {
  free(): void;
/**
* Create a new `DeviceId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the device ID as a string.
* @returns {string}
*/
  toString(): string;
}
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
export class DeviceKey {
  free(): void;
/**
* Convert the `DeviceKey` into a base64 encoded string.
* @returns {string}
*/
  toBase64(): string;
/**
* Get the value associated to the `Curve25519` device key name.
*/
  readonly curve25519: Curve25519PublicKey | undefined;
/**
* Get the value associated to the `Ed25519` device key name.
*/
  readonly ed25519: Ed25519PublicKey | undefined;
/**
* Get the name of the device key.
*/
  readonly name: number;
/**
* Get the value associated to the `Unknown` device key name.
*/
  readonly unknown: string | undefined;
}
/**
* The basic key algorithms in the specification.
*/
export class DeviceKeyAlgorithm {
  free(): void;
/**
* Return the device key algorithm as a string.
* @returns {string}
*/
  toString(): string;
/**
* Read the device key algorithm's name. If the name is
* `Unknown`, one may be interested by the `to_string` method to
* read the original name.
*/
  readonly name: number;
}
/**
* A Matrix device key ID.
*
* A key algorithm and a device ID, combined with a ‚Äò:‚Äô.
*/
export class DeviceKeyId {
  free(): void;
/**
* Parse/validate and create a new `DeviceKeyId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the device key ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns key algorithm of the device key ID.
*/
  readonly algorithm: DeviceKeyAlgorithm;
/**
* Returns device ID of the device key ID.
*/
  readonly deviceId: DeviceId;
}
/**
* Information on E2E device updates.
*/
export class DeviceLists {
  free(): void;
/**
* Create an empty `DeviceLists`.
*
* `changed` and `left` must be an array of `UserId`.
* @param {Array<any> | undefined} changed
* @param {Array<any> | undefined} left
*/
  constructor(changed?: Array<any>, left?: Array<any>);
/**
* Returns true if there are no device list updates.
* @returns {boolean}
*/
  isEmpty(): boolean;
/**
* List of users who have updated their device identity keys or
* who now share an encrypted room with the client since the
* previous sync
*/
  readonly changed: Array<any>;
/**
* List of users who no longer share encrypted rooms since the
* previous sync response.
*/
  readonly left: Array<any>;
}
/**
* An Ed25519 public key, used to verify digital signatures.
*/
export class Ed25519PublicKey {
  free(): void;
/**
* Serialize an Ed25519 public key to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
/**
* The number of bytes an Ed25519 public key has.
*/
  readonly length: number;
}
/**
* An Ed25519 digital signature, can be used to verify the
* authenticity of a message.
*/
export class Ed25519Signature {
  free(): void;
/**
* Try to create an Ed25519 signature from an unpadded base64
* representation.
* @param {string} signature
*/
  constructor(signature: string);
/**
* Serialize a Ed25519 signature to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
}
/**
* An emoji that is used for interactive verification using a short
* auth string.
*
* This will contain a single emoji and description from the list of
* emojis from [the specification].
*
* [the specification]: https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji
*/
export class Emoji {
  free(): void;
/**
* The description of the emoji, for example ‚ÄòDog‚Äô.
*/
  readonly description: string;
/**
* The emoji symbol that represents a part of the short auth
* string, for example: üê∂
*/
  readonly symbol: string;
}
/**
* An encrypted attachment, usually created from `Attachment.encrypt`.
*/
export class EncryptedAttachment {
  free(): void;
/**
* Create a new encrypted attachment manually.
*
* It needs encrypted data, stored in an `Uint8Array`, and a
* [media encryption
* information](https://docs.rs/matrix-sdk-crypto/latest/matrix_sdk_crypto/struct.MediaEncryptionInfo.html),
* as a JSON-encoded string.
*
* The media encryption information aren't stored as a string:
* they are parsed, validated and fully deserialized.
*
* See [the specification to learn
* more](https://spec.matrix.org/unstable/client-server-api/#extensions-to-mroommessage-msgtypes).
* @param {Uint8Array} encrypted_data
* @param {string} media_encryption_info
*/
  constructor(encrypted_data: Uint8Array, media_encryption_info: string);
/**
* The actual encrypted data.
*
* **Warning**: It returns a **copy** of the entire encrypted
* data; be nice with your memory.
*/
  readonly encryptedData: Uint8Array;
/**
* Check whether the media encryption info has been consumed by
* `Attachment.decrypt` already.
*/
  readonly hasMediaEncryptionInfoBeenConsumed: boolean;
/**
* Return the media encryption info as a JSON-encoded string. The
* structure is fully valid.
*
* If the media encryption info have been consumed already, it
* will return `null`.
*/
  readonly mediaEncryptionInfo: string | undefined;
}
/**
* Settings for an encrypted room.
*
* This determines the algorithm and rotation periods of a group
* session.
*/
export class EncryptionSettings {
  free(): void;
/**
* Create a new `EncryptionSettings` with default values.
*/
  constructor();
/**
* The encryption algorithm that should be used in the room.
*/
  algorithm: number;
/**
* The history visibility of the room when the session was
* created.
*/
  historyVisibility: number;
/**
* Should untrusted devices receive the room key, or should they be
* excluded from the conversation.
*/
  onlyAllowTrustedDevices: boolean;
/**
* How long the session should be used before changing it,
* expressed in microseconds.
*/
  rotationPeriod: bigint;
/**
* How many messages should be sent before changing the session.
*/
  rotationPeriodMessages: bigint;
}
/**
* A Matrix [event ID].
*
* An `EventId` is generated randomly or converted from a string
* slice, and can be converted back into a string as needed.
*
* [event ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
export class EventId {
  free(): void;
/**
* Parse/validate and create a new `EventId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the event ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns the event's localpart.
*/
  readonly localpart: string;
/**
* Returns the server name of the event ID.
*/
  readonly serverName: ServerName | undefined;
}
/**
* Struct holding the two public identity keys of an account.
*/
export class IdentityKeys {
  free(): void;
/**
* The Curve25519 public key, used for establish shared secrets.
*/
  curve25519: Curve25519PublicKey;
/**
* The Ed25519 public key, used for signing.
*/
  ed25519: Ed25519PublicKey;
}
/**
* Inbound group session.
*
* Inbound group sessions are used to exchange room messages between a group of
* participants. Inbound group sessions are used to decrypt the room messages.
*/
export class InboundGroupSession {
  free(): void;
/**
* Has the session been imported from a file or server-side backup? As
* opposed to being directly received as an `m.room_key` event.
* @returns {boolean}
*/
  hasBeenImported(): boolean;
/**
* The room where this session is used in.
*/
  readonly roomId: RoomId;
/**
* Returns the unique identifier for this session.
*/
  readonly sessionId: string;
}
/**
* A request that will back up a batch of room keys to the server
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3room_keyskeys
*/
export class KeysBackupRequest {
  free(): void;
/**
* Create a new `KeysBackupRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `rooms`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Data for a request to the `/keys/claim` API endpoint
* ([specification]).
*
* Claims one-time keys that can be used to establish 1-to-1 E2EE
* sessions.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysclaim
*/
export class KeysClaimRequest {
  free(): void;
/**
* Create a new `KeysClaimRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `timeout`,
* `one_time_keys`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Data for a request to the `/keys/query` API endpoint
* ([specification]).
*
* Returns the current devices and identity keys for the given users.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysquery
*/
export class KeysQueryRequest {
  free(): void;
/**
* Create a new `KeysQueryRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `timeout`,
* `device_keys`, `token`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Outgoing Requests * 
* Data for a request to the `/keys/upload` API endpoint
* ([specification]).
*
* Publishes end-to-end encryption keys for the device.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysupload
*/
export class KeysUploadRequest {
  free(): void;
/**
* Create a new `KeysUploadRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `device_keys`,
* `one_time_keys`, `fallback_keys`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Represents a signature that is either valid _or_ that could not be
* decoded.
*/
export class MaybeSignature {
  free(): void;
/**
* Check whether the signature has been successfully decoded.
* @returns {boolean}
*/
  isValid(): boolean;
/**
* Check whether the signature could not be successfully decoded.
* @returns {boolean}
*/
  isInvalid(): boolean;
/**
* The base64 encoded string that is claimed to contain a
* signature but could not be decoded, if any.
*/
  readonly invalidSignatureSource: string | undefined;
/**
* The signature, if successfully decoded.
*/
  readonly signature: Signature | undefined;
}
/**
* State machine implementation of the Olm/Megolm encryption protocol
* used for Matrix end to end encryption.
*/
export class OlmMachine {
  free(): void;
/**
* Constructor will always fail. To create a new `OlmMachine`, please use
* the `initialize` method.
*
* Why this pattern? `initialize` returns a `Promise`. Returning a
*/
  constructor();
/**
* Create a new `OlmMachine`.
*
* The created machine will keep the encryption keys either in a IndexedDB
* based store, or in a memory store and once the objects is dropped,
* the keys will be lost.
*
* # Arguments
*
* * `user_id` - represents the unique ID of the user that owns this
* machine.
*
* * `device_id` - represents the unique ID of the device
* that owns this machine.
*
* * `store_name` - The name that should be used to open the IndexedDB
*   based database. If this isn't provided, a memory-only store will be
*   used. *Note* the memory-only store will lose your E2EE keys when the
*   `OlmMachine` gets dropped.
*
* * `store_passphrase` - The passphrase that should be used to encrypt the
*   IndexedDB based
* @param {UserId} user_id
* @param {DeviceId} device_id
* @param {string | undefined} store_name
* @param {string | undefined} store_passphrase
* @returns {Promise<any>}
*/
  static initialize(user_id: UserId, device_id: DeviceId, store_name?: string, store_passphrase?: string): Promise<any>;
/**
* Get the list of users whose devices we are currently tracking.
*
* A user can be marked for tracking using the
* [`update_tracked_users`](#method.update_tracked_users) method.
*
* Returns a `Set<UserId>`.
* @returns {Promise<any>}
*/
  trackedUsers(): Promise<any>;
/**
* Update the list of tracked users.
*
* The OlmMachine maintains a list of users whose devices we are keeping
* track of: these are known as "tracked users". These must be users
* that we share a room with, so that the server sends us updates for
* their device lists.
*
* # Arguments
*
* * `users` - An array of user ids that should be added to the list of
*   tracked users
*
* Any users that hadn't been seen before will be flagged for a key query
* immediately, and whenever `receive_sync_changes` receives a
* "changed" notification for that user in the future.
*
* Users that were already in the list are unaffected.
* @param {Array<any>} users
* @returns {Promise<any>}
*/
  updateTrackedUsers(users: Array<any>): Promise<any>;
/**
* Handle to-device events and one-time key counts from a sync
* response.
*
* This will decrypt and handle to-device events returning the
* decrypted versions of them.
*
* To decrypt an event from the room timeline call
* `decrypt_room_event`.
* @param {string} to_device_events
* @param {DeviceLists} changed_devices
* @param {Map<any, any>} one_time_key_counts
* @param {Set<any>} unused_fallback_keys
* @returns {Promise<any>}
*/
  receiveSyncChanges(to_device_events: string, changed_devices: DeviceLists, one_time_key_counts: Map<any, any>, unused_fallback_keys: Set<any>): Promise<any>;
/**
* Get the outgoing requests that need to be sent out.
*
* This returns a list of `JsValue` to represent either:
*   * `KeysUploadRequest`,
*   * `KeysQueryRequest`,
*   * `KeysClaimRequest`,
*   * `ToDeviceRequest`,
*   * `SignatureUploadRequest`,
*   * `RoomMessageRequest` or
*   * `KeysBackupRequest`.
*
* Those requests need to be sent out to the server and the
* responses need to be passed back to the state machine using
* `mark_request_as_sent`.
* @returns {Promise<any>}
*/
  outgoingRequests(): Promise<any>;
/**
* Mark the request with the given request ID as sent (see
* `outgoing_requests`).
*
* Arguments are:
*
* * `request_id` represents the unique ID of the request that was sent
*   out. This is needed to couple the response with the now sent out
*   request.
* * `response_type` represents the type of the request that was sent out.
* * `response` represents the response that was received from the server
*   after the outgoing request was sent out.
* @param {string} request_id
* @param {number} request_type
* @param {string} response
* @returns {Promise<any>}
*/
  markRequestAsSent(request_id: string, request_type: number, response: string): Promise<any>;
/**
* Encrypt a room message for the given room.
*
* Beware that a room key needs to be shared before this
* method can be called using the `share_room_key` method.
*
* `room_id` is the ID of the room for which the message should
* be encrypted. `event_type` is the type of the event. `content`
* is the plaintext content of the message that should be
* encrypted.
*
* # Panics
*
* Panics if a group session for the given room wasn't shared
* beforehand.
* @param {RoomId} room_id
* @param {string} event_type
* @param {string} content
* @returns {Promise<any>}
*/
  encryptRoomEvent(room_id: RoomId, event_type: string, content: string): Promise<any>;
/**
* Decrypt an event from a room timeline.
*
* # Arguments
*
* * `event`, the event that should be decrypted.
* * `room_id`, the ID of the room where the event was sent to.
* @param {string} event
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  decryptRoomEvent(event: string, room_id: RoomId): Promise<any>;
/**
* Get the status of the private cross signing keys.
*
* This can be used to check which private cross signing keys we
* have stored locally.
* @returns {Promise<any>}
*/
  crossSigningStatus(): Promise<any>;
/**
* Export all the private cross signing keys we have.
*
* The export will contain the seed for the ed25519 keys as a
* unpadded base64 encoded string.
*
* This method returns None if we don‚Äôt have any private cross
* signing keys.
* @returns {Promise<any>}
*/
  exportCrossSigningKeys(): Promise<any>;
/**
* Import our private cross signing keys.
*
* The export needs to contain the seed for the ed25519 keys as
* an unpadded base64 encoded string.
* @param {CrossSigningKeyExport} _export
* @returns {Promise<any>}
*/
  importCrossSigningKeys(_export: CrossSigningKeyExport): Promise<any>;
/**
* Create a new cross signing identity and get the upload request
* to push the new public keys to the server.
*
* Warning: This will delete any existing cross signing keys that
* might exist on the server and thus will reset the trust
* between all the devices.
*
* Uploading these keys will require user interactive auth.
* @param {boolean} reset
* @returns {Promise<any>}
*/
  bootstrapCrossSigning(reset: boolean): Promise<any>;
/**
* Get the cross signing user identity of a user.
* @param {UserId} user_id
* @returns {Promise<any>}
*/
  getIdentity(user_id: UserId): Promise<any>;
/**
* Sign the given message using our device key and if available
* cross-signing master key.
* @param {string} message
* @returns {Promise<any>}
*/
  sign(message: string): Promise<any>;
/**
* Invalidate the currently active outbound group session for the
* given room.
*
* Returns true if a session was invalidated, false if there was
* no session to invalidate.
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  invalidateGroupSession(room_id: RoomId): Promise<any>;
/**
* Get to-device requests to share a room key with users in a room.
*
* `room_id` is the room ID. `users` is an array of `UserId`
* objects. `encryption_settings` are an `EncryptionSettings`
* object.
*
* Returns an array of `ToDeviceRequest`s.
* @param {RoomId} room_id
* @param {Array<any>} users
* @param {EncryptionSettings} encryption_settings
* @returns {Promise<any>}
*/
  shareRoomKey(room_id: RoomId, users: Array<any>, encryption_settings: EncryptionSettings): Promise<any>;
/**
* Get the a key claiming request for the user/device pairs that
* we are missing Olm sessions for.
*
* Returns `null` if no key claiming request needs to be sent
* out, otherwise it returns a `KeysClaimRequest` object.
*
* Sessions need to be established between devices so group
* sessions for a room can be shared with them.
*
* This should be called every time a group session needs to be
* shared as well as between sync calls. After a sync some
* devices may request room keys without us having a valid Olm
* session with them, making it impossible to server the room key
* request, thus it‚Äôs necessary to check for missing sessions
* between sync as well.
*
* Note: Care should be taken that only one such request at a
* time is in flight, e.g. using a lock.
*
* The response of a successful key claiming requests needs to be
* passed to the `OlmMachine` with the `mark_request_as_sent`.
*
* `users` represents the list of users that we should check if
* we lack a session with one of their devices. This can be an
* empty iterator when calling this method between sync requests.
* @param {Array<any>} users
* @returns {Promise<any>}
*/
  getMissingSessions(users: Array<any>): Promise<any>;
/**
* Get a map holding all the devices of a user.
*
* `user_id` represents the unique ID of the user that the
* devices belong to.
* @param {UserId} user_id
* @returns {Promise<any>}
*/
  getUserDevices(user_id: UserId): Promise<any>;
/**
* Get a specific device of a user if one is found and the crypto store
* didn't throw an error.
*
* `user_id` represents the unique ID of the user that the
* identity belongs to. `device_id` represents the unique ID of
* the device.
* @param {UserId} user_id
* @param {DeviceId} device_id
* @returns {Promise<any>}
*/
  getDevice(user_id: UserId, device_id: DeviceId): Promise<any>;
/**
* Get a verification object for the given user ID with the given
* flow ID (a to-device request ID if the verification has been
* requested by a to-device request, or a room event ID if the
* verification has been requested by a room event).
*
* It returns a ‚Äú`Verification` object‚Äù, which is either a `Sas`
* or `Qr` object.
* @param {UserId} user_id
* @param {string} flow_id
* @returns {any}
*/
  getVerification(user_id: UserId, flow_id: string): any;
/**
* Get a verification request object with the given flow ID.
* @param {UserId} user_id
* @param {string} flow_id
* @returns {VerificationRequest | undefined}
*/
  getVerificationRequest(user_id: UserId, flow_id: string): VerificationRequest | undefined;
/**
* Get all the verification requests of a given user.
* @param {UserId} user_id
* @returns {Array<any>}
*/
  getVerificationRequests(user_id: UserId): Array<any>;
/**
* Receive a verification event.
*
* This method can be used to pass verification events that are happening
* in rooms to the `OlmMachine`. The event should be in the decrypted form.
* @param {string} event
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  receiveVerificationEvent(event: string, room_id: RoomId): Promise<any>;
/**
* Export the keys that match the given predicate.
*
* `predicate` is a closure that will be called for every known
* `InboundGroupSession`, which represents a room key. If the closure
* returns `true`, the `InboundGroupSession` will be included in the
* export, otherwise it won't.
* @param {Function} predicate
* @returns {Promise<any>}
*/
  exportRoomKeys(predicate: Function): Promise<any>;
/**
* Import the given room keys into our store.
*
* `exported_keys` is a list of previously exported keys that should be
* imported into our store. If we already have a better version of a key,
* the key will _not_ be imported.
*
* `progress_listener` is a closure that takes 2 arguments: `progress` and
* `total`, and returns nothing.
* @param {string} exported_room_keys
* @param {Function} progress_listener
* @returns {Promise<any>}
*/
  importRoomKeys(exported_room_keys: string, progress_listener: Function): Promise<any>;
/**
* Encrypt the list of exported room keys using the given passphrase.
*
* `exported_room_keys` is a list of sessions that should be encrypted
* (it's generally returned by `export_room_keys`). `passphrase` is the
* passphrase that will be used to encrypt the exported room keys. And
* `rounds` is the number of rounds that should be used for the key
* derivation when the passphrase gets turned into an AES key. More rounds
* are increasingly computationnally intensive and as such help against
* brute-force attacks. Should be at least `10_000`, while values in the
* `100_000` ranges should be preferred.
* @param {string} exported_room_keys
* @param {string} passphrase
* @param {number} rounds
* @returns {string}
*/
  static encryptExportedRoomKeys(exported_room_keys: string, passphrase: string, rounds: number): string;
/**
* Try to decrypt a reader into a list of exported room keys.
*
* `encrypted_exported_room_keys` is the result from
* `encrypt_exported_room_keys`. `passphrase` is the passphrase that was
* used when calling `encrypt_exported_room_keys`.
* @param {string} encrypted_exported_room_keys
* @param {string} passphrase
* @returns {string}
*/
  static decryptExportedRoomKeys(encrypted_exported_room_keys: string, passphrase: string): string;
/**
* Shut down the `OlmMachine`.
*
* The `OlmMachine` cannot be used after this method has been called.
*
* All associated resources will be closed too, like IndexedDB
* connections.
*/
  close(): void;
/**
* The unique device ID that identifies this `OlmMachine`.
*/
  readonly deviceId: DeviceId;
/**
* Get the display name of our own device.
*/
  readonly displayName: Promise<any>;
/**
* Get the public parts of our Olm identity keys.
*/
  readonly identityKeys: IdentityKeys;
/**
* The unique user ID that owns this `OlmMachine` instance.
*/
  readonly userId: UserId;
}
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that is our own.
*/
export class OwnUserIdentity {
  free(): void;
/**
* Mark our user identity as verified.
*
* This will mark the identity locally as verified and sign it with our own
* device.
*
* Returns a signature upload request that needs to be sent out.
* @returns {Promise<any>}
*/
  verify(): Promise<any>;
/**
* Send a verification request to our other devices.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(methods?: Array<any>): Promise<any>;
/**
* Does our user identity trust our own device, i.e. have we signed our own
* device keys with our self-signing key?
* @returns {Promise<any>}
*/
  trustsOurOwnDevice(): Promise<any>;
}
/**
* QR code based verification.
*/
export class Qr {
  free(): void;
/**
* Has the QR verification been scanned by the other side.
*
* When the verification object is in this state it‚Äôs required
* that the user confirms that the other side has scanned the QR
* code.
* @returns {boolean}
*/
  hasBeenScanned(): boolean;
/**
* Has the scanning of the QR code been confirmed by us.
* @returns {boolean}
*/
  hasBeenConfirmed(): boolean;
/**
* Did we initiate the verification request.
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Get info about the cancellation if the verification flow has
* been cancelled.
* @returns {CancelInfo | undefined}
*/
  cancelInfo(): CancelInfo | undefined;
/**
* Has the verification flow completed.
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Has the verification flow been cancelled.
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Is this a verification that is veryfying one of our own devices.
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Have we successfully scanned the QR code and are able to send
* a reciprocation event.
* @returns {boolean}
*/
  reciprocated(): boolean;
/**
* Generate a QR code object that is representing this
* verification flow.
*
* The QrCode can then be rendered as an image or as an unicode
* string.
*
* The `to_bytes` method can be used to instead output the raw
* bytes that should be encoded as a QR code.
* @returns {QrCode}
*/
  toQrCode(): QrCode;
/**
* Generate a the raw bytes that should be encoded as a QR code
* is representing this verification flow.
*
* The `to_qr_code` method can be used to instead output a QrCode
* object that can be rendered.
* @returns {Uint8ClampedArray}
*/
  toBytes(): Uint8ClampedArray;
/**
* Notify the other side that we have successfully scanned the QR
* code and that the QR verification flow can start.
*
* This will return some OutgoingContent if the object is in the
* correct state to start the verification flow, otherwise None.
* @returns {any}
*/
  reciprocate(): any;
/**
* Confirm that the other side has scanned our QR code.
* @returns {any}
*/
  confirmScanning(): any;
/**
* Cancel the verification flow.
* @returns {any}
*/
  cancel(): any;
/**
* Cancel the verification.
*
* This cancels the verification with given code.
* @param {number} code
* @returns {any}
*/
  cancelWithCode(code: number): any;
/**
* Get the unique ID that identifies this QR verification flow,
* be either a to-device request ID or a room event ID.
*/
  readonly flowId: string;
/**
* Get the device ID of the other side.
*/
  readonly otherDeviceId: DeviceId;
/**
* Get the user id of the other user that is participating in
* this verification flow.
*/
  readonly otherUserId: UserId;
/**
* Get the room id if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get our own user ID.
*/
  readonly userId: UserId;
}
/**
* A QR code.
*/
export class QrCode {
  free(): void;
/**
* Render the QR code into a `Uint8ClampedArray` where 1 represents a
* dark pixel and 0 a white pixel.
* @returns {Uint8ClampedArray}
*/
  renderIntoBuffer(): Uint8ClampedArray;
}
/**
* A scanned QR code.
*/
export class QrCodeScan {
  free(): void;
/**
* Parse the decoded payload of a QR code in byte slice form.
*
* This method is useful if you would like to do your own custom QR code
* decoding.
* @param {Uint8ClampedArray} buffer
* @returns {QrCodeScan}
*/
  static fromBytes(buffer: Uint8ClampedArray): QrCodeScan;
}
/**
* A Matrix [room ID].
*
* [room ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
export class RoomId {
  free(): void;
/**
* Parse/validate and create a new `RoomId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the room ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns the user's localpart.
*/
  readonly localpart: string;
/**
* Returns the server name of the room ID.
*/
  readonly serverName: ServerName;
}
/**
* A customized owned request type for sending out room messages
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid
*/
export class RoomMessageRequest {
  free(): void;
/**
* Create a new `RoomMessageRequest`.
* @param {string} id
* @param {string} room_id
* @param {string} txn_id
* @param {string} event_type
* @param {string} content
*/
  constructor(id: string, room_id: string, txn_id: string, event_type: string, content: string);
/**
* A JSON-encoded string containing the message's content.
*/
  readonly body: string;
/**
* A string representing the type of event to be sent.
*/
  readonly event_type: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* A string representing the room to send the event to.
*/
  readonly room_id: string;
/**
* A string representing the transaction ID for this event.
*
* Clients should generate an ID unique across requests with the same
* access token; it will be used by the server to ensure idempotency of
* requests.
*/
  readonly txn_id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Short Authentication String (SAS) verification.
*/
export class Sas {
  free(): void;
/**
* Does this verification flow support displaying emoji for the
* short authentication string.
* @returns {boolean}
*/
  supportsEmoji(): boolean;
/**
* Did this verification flow start from a verification request.
* @returns {boolean}
*/
  startedFromRequest(): boolean;
/**
* Is this a verification that is veryfying one of our own
* devices.
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Have we confirmed that the short auth string matches.
* @returns {boolean}
*/
  haveWeConfirmed(): boolean;
/**
* Has the verification been accepted by both parties.
* @returns {boolean}
*/
  hasBeenAccepted(): boolean;
/**
* Get info about the cancellation if the verification flow has
* been cancelled.
* @returns {CancelInfo | undefined}
*/
  cancelInfo(): CancelInfo | undefined;
/**
* Did we initiate the verification flow.
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Accept the SAS verification.
*
* This does nothing if the verification was already accepted,
* otherwise it returns an `AcceptEventContent` that needs to be
* sent out.
* @returns {any}
*/
  accept(): any;
/**
* Confirm the SAS verification.
*
* This confirms that the short auth strings match on both sides.
*
* Does nothing if we‚Äôre not in a state where we can confirm the
* short auth string, otherwise returns a `MacEventContent` that
* needs to be sent to the server.
* @returns {Promise<any>}
*/
  confirm(): Promise<any>;
/**
* Cancel the verification.
* @returns {any}
*/
  cancel(): any;
/**
* Cancel the verification.
*
* This cancels the verification with given code.
* @param {number} code
* @returns {any}
*/
  cancelWithCode(code: number): any;
/**
* Has the SAS verification flow timed out.
* @returns {boolean}
*/
  timedOut(): boolean;
/**
* Are we in a state where we can show the short auth string.
* @returns {boolean}
*/
  canBePresented(): boolean;
/**
* Is the SAS flow done.
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Is the SAS flow canceled.
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Get the emoji version of the short auth string.
*
* Returns `undefined` if we can't yet present the short auth string,
* otherwise seven tuples containing the emoji and description.
* @returns {Array<any> | undefined}
*/
  emoji(): Array<any> | undefined;
/**
* Get the index of the emoji representing the short auth string
*
* Returns `undefined` if we can‚Äôt yet present the short auth
* string, otherwise seven `u8` numbers in the range from 0 to 63
* inclusive which can be converted to an emoji using [the
* relevant specification
* entry](https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji).
* @returns {Array<any> | undefined}
*/
  emojiIndex(): Array<any> | undefined;
/**
* Get the decimal version of the short auth string.
*
* Returns None if we can‚Äôt yet present the short auth string,
* otherwise a tuple containing three 4-digit integers that
* represent the short auth string.
* @returns {Array<any> | undefined}
*/
  decimals(): Array<any> | undefined;
/**
* Get our own device ID.
*/
  readonly deviceId: DeviceId;
/**
* Get the unique ID that identifies this SAS verification flow,
* be either a to-device request ID or a room event ID.
*/
  readonly flowId: string;
/**
* Get the device ID of the other side.
*/
  readonly otherDeviceId: DeviceId;
/**
* Get the user id of the other side.
*/
  readonly otherUserId: UserId;
/**
* Get the room ID if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get our own user ID.
*/
  readonly userId: UserId;
}
/**
* A Matrix-spec compliant [server name].
*
* It consists of a host and an optional port (separated by a colon if
* present).
*
* [server name]: https://spec.matrix.org/v1.2/appendices/#server-name
*/
export class ServerName {
  free(): void;
/**
* Parse/validate and create a new `ServerName`.
* @param {string} name
*/
  constructor(name: string);
/**
* Returns true if and only if the server name is an IPv4 or IPv6
* address.
* @returns {boolean}
*/
  isIpLiteral(): boolean;
/**
* Returns the host of the server name.
*
* That is: Return the part of the server before `:<port>` or the
* full server name if there is no port.
*/
  readonly host: string;
/**
* Returns the port of the server name if any.
*/
  readonly port: number | undefined;
}
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
export class ShieldState {
  free(): void;
/**
* The shield color
*/
  color: number;
/**
* Error message that can be displayed as a tooltip
*/
  readonly message: string | undefined;
}
/**
* Represents a potentially decoded signature (but not a validated
* one).
*/
export class Signature {
  free(): void;
/**
* Convert the signature to a base64 encoded string.
* @returns {string}
*/
  toBase64(): string;
/**
* Get the Ed25519 signature, if this is one.
*/
  readonly ed25519: Ed25519Signature | undefined;
}
/**
* Data for a request to the `/keys/signatures/upload` API endpoint
* ([specification]).
*
* Publishes cross-signing signatures for the user.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keyssignaturesupload
*/
export class SignatureUploadRequest {
  free(): void;
/**
* Create a new `SignatureUploadRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `signed_keys`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* A collection of `Signature`.
*/
export class Signatures {
  free(): void;
/**
* Creates a new, empty, signatures collection.
*/
  constructor();
/**
* Add the given signature from the given signer and the given key ID to
* the collection.
* @param {UserId} signer
* @param {DeviceKeyId} key_id
* @param {Ed25519Signature} signature
* @returns {MaybeSignature | undefined}
*/
  addSignature(signer: UserId, key_id: DeviceKeyId, signature: Ed25519Signature): MaybeSignature | undefined;
/**
* Try to find an Ed25519 signature from the given signer with
* the given key ID.
* @param {UserId} signer
* @param {DeviceKeyId} key_id
* @returns {Ed25519Signature | undefined}
*/
  getSignature(signer: UserId, key_id: DeviceKeyId): Ed25519Signature | undefined;
/**
* Get the map of signatures that belong to the given user.
* @param {UserId} signer
* @returns {Map<any, any> | undefined}
*/
  get(signer: UserId): Map<any, any> | undefined;
/**
* Remove all the signatures we currently hold.
*/
  clear(): void;
/**
* Do we hold any signatures or is our collection completely
* empty.
* @returns {boolean}
*/
  isEmpty(): boolean;
/**
* How many signatures do we currently hold.
*/
  readonly count: number;
}
/**
* Other Requests * 
* Request that will publish a cross signing identity.
*
* This uploads the public cross signing key triplet.
*/
export class SigningKeysUploadRequest {
  free(): void;
/**
* A JSON-encoded string containing the rest of the payload: `master_key`,
* `self_signing_key`, `user_signing_key`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
}
/**
* Data for a request to the `/sendToDevice` API endpoint
* ([specification]).
*
* Send an event to a single device or to a group of devices.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3sendtodeviceeventtypetxnid
*/
export class ToDeviceRequest {
  free(): void;
/**
* Create a new `ToDeviceRequest`.
* @param {string} id
* @param {string} event_type
* @param {string} txn_id
* @param {string} body
*/
  constructor(id: string, event_type: string, txn_id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `messages`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* A string representing the type of event being sent to each devices.
*/
  readonly event_type: string;
/**
* The request ID.
*/
  readonly id: string | undefined;
/**
* A string representing a request identifier unique to the access token
* used to send the request.
*/
  readonly txn_id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Type to install and to manipulate the tracing layer.
*/
export class Tracing {
  free(): void;
/**
* Check whether the `tracing` feature has been enabled.
* @returns {boolean}
*/
  static isAvailable(): boolean;
/**
* Install the tracing layer.
*
* `Tracing` is a singleton. Once it is installed,
* consecutive calls to the constructor will construct a new
* `Tracing` object but with the exact same inner
* state. Calling the constructor with a new `min_level` will
* just update the `min_level` parameter; in that regard, it
* is similar to calling the `min_level` method on an
* existing `Tracing` object.
* @param {number} min_level
*/
  constructor(min_level: number);
/**
* Turn the logger on, i.e. it emits logs again if it was turned
* off.
*/
  turnOn(): void;
/**
* Turn the logger off, i.e. it no long emits logs.
*/
  turnOff(): void;
/**
* Re-define the minimum logger level.
*/
  minLevel: number;
}
/**
* A read only view over all devices belonging to a user.
*/
export class UserDevices {
  free(): void;
/**
* Get the specific device with the given device ID.
* @param {DeviceId} device_id
* @returns {Device | undefined}
*/
  get(device_id: DeviceId): Device | undefined;
/**
* Returns true if there is at least one devices of this user
* that is considered to be verified, false otherwise.
*
* This won't consider your own device as verified, as your own
* device is always implicitly verified.
* @returns {boolean}
*/
  isAnyVerified(): boolean;
/**
* Array over all the device IDs of the user devices.
* @returns {Array<any>}
*/
  keys(): Array<any>;
/**
* Iterator over all the devices of the user devices.
* @returns {Array<any>}
*/
  devices(): Array<any>;
}
/**
* A Matrix [user ID].
*
* [user ID]: https://spec.matrix.org/v1.2/appendices/#user-identifiers
*/
export class UserId {
  free(): void;
/**
* Parse/validate and create a new `UserId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Whether this user ID is a historical one.
*
* A historical user ID is one that doesn't conform to the latest
* specification of the user ID grammar but is still accepted
* because it was previously allowed.
* @returns {boolean}
*/
  isHistorical(): boolean;
/**
* Return the user ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns the user's localpart.
*/
  readonly localpart: string;
/**
* Returns the server name of the user ID.
*/
  readonly serverName: ServerName;
}
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that isn't our own. Other users will
* only contain a master key and a self signing key, meaning that only device
* signatures can be checked with this identity.
*
* This struct wraps a read-only version of the struct and allows verifications
* to be requested to verify our own device with the user identity.
*/
export class UserIdentity {
  free(): void;
/**
* Is this user identity verified?
* @returns {boolean}
*/
  isVerified(): boolean;
/**
* Manually verify this user.
*
* This method will attempt to sign the user identity using our private
* cross signing key.
*
* This method fails if we don't have the private part of our user-signing
* key.
*
* Returns a request that needs to be sent out for the user to be marked as
* verified.
* @returns {Promise<any>}
*/
  verify(): Promise<any>;
/**
* Create a `VerificationRequest` object after the verification
* request content has been sent out.
* @param {RoomId} room_id
* @param {EventId} request_event_id
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(room_id: RoomId, request_event_id: EventId, methods?: Array<any>): Promise<any>;
/**
* Send a verification request to the given user.
*
* The returned content needs to be sent out into a DM room with the given
* user.
*
* After the content has been sent out a VerificationRequest can be started
* with the `request_verification` method.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  verificationRequestContent(methods?: Array<any>): Promise<any>;
}
/**
* An object controlling key verification requests.
*
* Interactive verification flows usually start with a verification
* request, this object lets you send and reply to such a
* verification request.
*
* After the initial handshake the verification flow transitions into
* one of the verification methods.
*/
export class VerificationRequest {
  free(): void;
/**
* Create an event content that can be sent as a room event to
* request verification from the other side. This should be used
* only for verifications of other users and it should be sent to
* a room we consider to be a DM with the other user.
* @param {UserId} own_user_id
* @param {DeviceId} own_device_id
* @param {UserId} other_user_id
* @param {Array<any> | undefined} methods
* @returns {string}
*/
  static request(own_user_id: UserId, own_device_id: DeviceId, other_user_id: UserId, methods?: Array<any>): string;
/**
* Has the verification request been answered by another device.
* @returns {boolean}
*/
  isPassive(): boolean;
/**
* Is the verification request ready to start a verification flow.
* @returns {boolean}
*/
  isReady(): boolean;
/**
* Has the verification flow timed out.
* @returns {boolean}
*/
  timedOut(): boolean;
/**
* Is this a verification that is veryfying one of our own
* devices.
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Did we initiate the verification request.
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Has the verification flow that was started with this request
* finished.
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Has the verification flow that was started with this request
* been cancelled.
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Accept the verification request signaling that our client
* supports the given verification methods.
*
* `methods` represents the methods that we should advertise as
* supported by us.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @param {Array<any>} methods
* @returns {any}
*/
  acceptWithMethods(methods: Array<any>): any;
/**
* Accept the verification request.
*
* This method will accept the request and signal that it
* supports the `m.sas.v1`, the `m.qr_code.show.v1`, and
* `m.reciprocate.v1` method.
*
* `m.qr_code.show.v1` will only be signaled if the `qrcode`
* feature is enabled. This feature is disabled by default. If
* it's enabled and QR code scanning should be supported or QR
* code showing shouldn't be supported the `accept_with_methods`
* method should be used instead.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @returns {any}
*/
  accept(): any;
/**
* Cancel the verification request.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @returns {any}
*/
  cancel(): any;
/**
* Transition from this verification request into a SAS verification flow.
* @returns {Promise<any>}
*/
  startSas(): Promise<any>;
/**
* Generate a QR code that can be used by another client to start
* a QR code based verification.
* @returns {Promise<any>}
*/
  generateQrCode(): Promise<any>;
/**
* Start a QR code verification by providing a scanned QR code
* for this verification flow.
* @param {QrCodeScan} data
* @returns {Promise<any>}
*/
  scanQrCode(data: QrCodeScan): Promise<any>;
/**
* Get info about the cancellation if the verification request
* has been cancelled.
*/
  readonly cancelInfo: CancelInfo | undefined;
/**
* Get the unique ID of this verification request
*/
  readonly flowId: string;
/**
* The ID of the other device that is participating in this
* verification.
*/
  readonly otherDeviceId: DeviceId | undefined;
/**
* The ID of the other user that is participating in this
* verification request.
*/
  readonly otherUserId: UserId;
/**
* Get our own supported verification methods that we advertised.
*
* Will be present only we requested the verification or if we‚Äôre
* in the ready state.
*/
  readonly ourSupportedMethods: Array<any> | undefined;
/**
* Our own user id.
*/
  readonly ownUserId: UserId;
/**
* Get the room ID if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get the supported verification methods of the other side.
*
* Will be present only if the other side requested the
* verification or if we‚Äôre in the ready state.
*
* It return a `Option<Vec<VerificationMethod>>`.
*/
  readonly theirSupportedMethods: Array<any> | undefined;
}
/**
* Object containing the versions of the Rust libraries we are using.
*/
export class Versions {
  free(): void;
/**
* The version of the matrix-sdk-crypto crate.
*/
  readonly matrix_sdk_crypto: string;
/**
* The version of the vodozemac crate.
*/
  readonly vodozemac: string;
}
/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
export function initAsync(): Promise<void>;
